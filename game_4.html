<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris Multiplayer - Competitive Rewrite</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Orbitron:wght@400;700;900&display=swap');
        :root {
            --bg-dark: #0a0e27;
            --bg-grid: #151b3d;
            --border-glow: #00ffff;
            --text-primary: #ffffff;
            --text-secondary: #8b9dc3;
            --accent-cyan: #00ffff;
            --accent-pink: #ff00ff;
            --accent-yellow: #ffff00;
            --shadow-glow: 0 0 20px rgba(0, 255, 255, 0.5);
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Orbitron', monospace;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f4d 100%);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }
        
        /* Scanline effect */
        body::before {
            content: '';
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0, 255, 255, 0.03) 2px, rgba(0, 255, 255, 0.03) 4px);
            pointer-events: none;
            z-index: 999;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 1;
        }
        
        h1 {
            font-family: 'Press Start 2P', cursive;
            text-align: center;
            font-size: 2rem;
            margin-bottom: 30px;
            text-transform: uppercase;
            background: linear-gradient(45deg, var(--accent-cyan), var(--accent-pink), var(--accent-yellow));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 10px rgba(0, 255, 255, 0.5));
        }
        
        /* Game Layout */
        .game-area {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin-top: 30px;
            flex-wrap: wrap;
        }
        
        .player-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        
        .game-wrapper {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }
        
        .side-panel { display: flex; flex-direction: column; gap: 15px; }
        
        .info-box {
            background: rgba(21, 27, 61, 0.9);
            border: 2px solid var(--accent-cyan);
            border-radius: 8px;
            padding: 15px;
            min-width: 150px;
            box-shadow: var(--shadow-glow);
        }
        
        .info-box h3 {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.6rem;
            margin-bottom: 10px;
            color: var(--accent-yellow);
            text-align: center;
        }
        
        .canvas-container {
            position: relative;
            border: 3px solid var(--border-glow);
            border-radius: 5px;
            box-shadow: var(--shadow-glow);
            background: rgba(10, 14, 39, 0.95);
        }
        
        canvas { display: block; image-rendering: pixelated; }
        
        .mini-canvas-container {
            background: rgba(10, 14, 39, 0.9);
            border: 2px solid var(--accent-pink);
            border-radius: 5px;
            padding: 10px;
            display: flex; justify-content: center; align-items: center;
        }
        
        /* UI Elements */
        button {
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-pink));
            border: none; color: var(--bg-dark);
            padding: 12px 24px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.7rem;
            border-radius: 5px; cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 255, 255, 0.3);
            transition: transform 0.1s;
        }
        button:hover { transform: translateY(-2px); }
        button:active { transform: translateY(0); }
        button:disabled { opacity: 0.5; cursor: not-allowed; }

        .hidden { display: none !important; }

        /* Settings Modal */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 1000;
            display: flex; justify-content: center;
            align-items: center;
            backdrop-filter: blur(5px);
        }
        
        .modal-content {
            background: rgba(21, 27, 61, 0.95);
            border: 2px solid var(--accent-cyan);
            padding: 30px;
            border-radius: 15px;
            width: 90%;
            max-width: 600px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.2);
            max-height: 90vh;
            overflow-y: auto;
        }

        .settings-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .setting-group { margin-bottom: 15px; }
        .setting-group h3 { 
            color: var(--accent-pink);
            font-size: 0.8rem; 
            margin-bottom: 10px; 
            border-bottom: 1px solid rgba(255,255,255,0.1); 
            padding-bottom: 5px;
        }

        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .control-row label { font-size: 0.8rem; color: var(--text-secondary); }
        
        .control-row input {
            background: rgba(10, 14, 39, 0.6);
            border: 1px solid var(--accent-cyan);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            width: 120px;
            text-align: center;
            cursor: pointer;
            font-family: 'Orbitron', monospace;
            font-size: 0.8rem;
        }
        
        .control-row input:focus { outline: none; border-color: var(--accent-yellow); box-shadow: 0 0 10px var(--accent-yellow); }

        .close-btn {
            width: 100%;
            margin-top: 10px;
            background: var(--bg-grid);
            border: 1px solid var(--accent-cyan);
            color: var(--accent-cyan);
        }
        .close-btn:hover { background: var(--accent-cyan); color: var(--bg-dark); }
        
        /* Chat */
        .chat-container {
            background: rgba(21, 27, 61, 0.9);
            border: 2px solid var(--border-glow);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
        }
        .chat-messages {
            height: 150px;
            overflow-y: auto;
            background: rgba(10, 14, 39, 0.8);
            border: 1px solid var(--accent-cyan);
            margin-bottom: 10px; padding: 10px;
            font-size: 0.8rem;
        }
        .chat-input-container { display: flex; gap: 10px; }
        .chat-input { flex: 1; padding: 10px; background: rgba(10, 14, 39, 0.9); border: 1px solid var(--accent-cyan); color: white; }
        
        /* Stats */
        .stat { display: flex; justify-content: space-between; margin: 5px 0; font-size: 0.8rem; }
        .stat-value { color: var(--accent-cyan); font-weight: bold; }

        #gameStatus { text-align: center; margin: 20px; color: var(--accent-yellow); font-family: 'Press Start 2P'; font-size: 0.8rem; }
        
        #myPeerId {
            background: rgba(21, 27, 61, 0.9);
            border: 2px solid var(--accent-cyan);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 20px;
        }
        
        .peer-id-value {
            font-family: 'Press Start 2P';
            color: var(--accent-cyan);
            padding: 10px; background: rgba(10, 14, 39, 0.8);
            border: 1px solid var(--accent-pink); margin-top: 5px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>⬛ Tetris Battle ⬛</h1>
        
        <div style="display:flex; justify-content:center; gap:10px; flex-wrap:wrap; margin-bottom:20px;">
            <button id="settingsBtn">⚙️ Settings</button>
            <button id="createGameBtn">Create Host</button>
            <button id="startGameBtn" class="hidden" style="background: linear-gradient(135deg, #00ff00, #008800); color: white;">START GAME</button>
        </div>

        <div style="display:flex; justify-content:center; gap:10px; flex-wrap:wrap; margin-bottom:20px;">
            <input type="text" id="opponentPeerId" placeholder="Enter Host ID" style="padding:10px; background: rgba(10, 14, 39, 0.9); border: 1px solid var(--accent-cyan); color: white;">
            <button id="joinGameBtn">Join Game</button>
            <button id="restartBtn" class="hidden">Restart Match</button>
        </div>

        <div id="myPeerId" class="hidden">
            <div style="font-size: 0.7rem; color: var(--text-secondary);">YOUR PEER ID:</div>
            <div class="peer-id-value" id="peerIdDisplay" onclick="copyPeerId()">Connecting...</div>
        </div>
        
        <div id="gameStatus">Waiting to start...</div>

        <div class="game-area hidden" id="gameArea">
            <div class="player-container">
                <div class="player-header">YOU</div>
                <div class="game-wrapper">
                    <div class="side-panel">
                        <div class="info-box">
                            <h3>HOLD</h3>
                            <div class="mini-canvas-container"><canvas id="holdCanvas1" width="80" height="80"></canvas></div>
                        </div>
                        <div class="info-box">
                            <div class="stat"><span>PPS:</span><span class="stat-value" id="pps1">0.00</span></div>
                            <div class="stat"><span>APM:</span><span class="stat-value" id="apm1">0.00</span></div>
                        </div>
                    </div>
                    <div class="canvas-container"><canvas id="gameCanvas1" width="320" height="640"></canvas></div>
                    <div class="side-panel">
                        <div class="info-box">
                            <h3>NEXT</h3>
                            <div class="mini-canvas-container"><canvas id="queueCanvas1" width="80" height="480"></canvas></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="player-container">
                <div class="player-header">OPPONENT</div>
                <div class="game-wrapper">
                    <div class="side-panel">
                        <div class="info-box">
                            <h3>HOLD</h3>
                            <div class="mini-canvas-container"><canvas id="holdCanvas2" width="80" height="80"></canvas></div>
                        </div>
                        <div class="info-box">
                            <div class="stat"><span>PPS:</span><span class="stat-value" id="pps2">0.00</span></div>
                            <div class="stat"><span>APM:</span><span class="stat-value" id="apm2">0.00</span></div>
                        </div>
                    </div>
                    <div class="canvas-container"><canvas id="gameCanvas2" width="320" height="640"></canvas></div>
                    <div class="side-panel">
                        <div class="info-box">
                            <h3>NEXT</h3>
                            <div class="mini-canvas-container"><canvas id="queueCanvas2" width="80" height="480"></canvas></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="chat-container">
            <div class="chat-messages" id="chatMessages"></div>
            <div class="chat-input-container">
                <input type="text" class="chat-input" id="chatInput" placeholder="Type message...">
                <button id="sendChatBtn">Send</button>
            </div>
        </div>
    </div>

    <div id="settingsModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h2 style="text-align: center; margin-bottom: 20px; font-family: 'Press Start 2P'; font-size: 1rem; color: var(--accent-yellow);">Game Settings</h2>
            
            <div class="settings-grid">
                <div class="setting-group">
                    <h3>Handling</h3>
                    <div class="control-row">
                        <label>ARR (ms)</label>
                        <input type="number" id="arrInput" value="0" min="0" max="100">
                    </div>
                    <div class="control-row">
                        <label>DAS (ms)</label>
                        <input type="number" id="dasInput" value="133" min="0" max="500">
                    </div>
                    <div class="control-row">
                        <label>SDF</label>
                        <input type="text" id="sdfInput" value="inf" placeholder="inf or number">
                    </div>
                </div>

                <div class="setting-group">
                    <h3>Movement</h3>
                    <div class="control-row"><label>Left</label><input type="text" id="bindLeft" readonly></div>
                    <div class="control-row"><label>Right</label><input type="text" id="bindRight" readonly></div>
                    <div class="control-row"><label>Soft Drop</label><input type="text" id="bindSoft" readonly></div>
                    <div class="control-row"><label>Hard Drop</label><input type="text" id="bindHard" readonly></div>
                </div>

                <div class="setting-group">
                    <h3>Rotation</h3>
                    <div class="control-row"><label>Rotate CW</label><input type="text" id="bindCW" readonly></div>
                    <div class="control-row"><label>Rotate CCW</label><input type="text" id="bindCCW" readonly></div>
                    <div class="control-row"><label>Rotate 180</label><input type="text" id="bind180" readonly></div>
                    <div class="control-row"><label>Hold</label><input type="text" id="bindHold" readonly></div>
                </div>
            </div>

            <div style="text-align: center; font-size: 0.7rem; color: var(--text-secondary); margin-bottom: 20px;">
                Click any control box to rebind.
            </div>
            
            <button class="close-btn" id="closeSettingsBtn">Close & Save</button>
        </div>
    </div>

    <script>
        /**
         * ENGINE CONSTANTS & DATA
         */
        const COLS = 10;
        const ROWS = 20;
        const BLOCK = 32;
        const PREVIEW_BLOCK = 16;
        
        // Modifiable Key Map
        let keyMap = {
            LEFT: 'ArrowLeft',
            RIGHT: 'ArrowRight',
            SOFT: 'ArrowDown',
            HARD: ' ',
            CW: 'ArrowUp',
            CCW: 'z',
            R180: 'x',
            HOLD: 'c'
        };

        const SHAPES = {
            I: { color: '#00f0f0', shape: [[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]], [[0,0,1,0],[0,0,1,0],[0,0,1,0],[0,0,1,0]], [[0,0,0,0],[0,0,0,0],[1,1,1,1],[0,0,0,0]], [[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]]] },
            J: { color: '#0000f0', shape: [[[1,0,0],[1,1,1],[0,0,0]], [[0,1,1],[0,1,0],[0,1,0]], [[0,0,0],[1,1,1],[0,0,1]], [[0,1,0],[0,1,0],[1,1,0]]] },
            L: { color: '#f0a000', shape: [[[0,0,1],[1,1,1],[0,0,0]], [[0,1,0],[0,1,0],[0,1,1]], [[0,0,0],[1,1,1],[1,0,0]], [[1,1,0],[0,1,0],[0,1,0]]] },
            O: { color: '#f0f000', shape: [[[1,1],[1,1]], [[1,1],[1,1]], [[1,1],[1,1]], [[1,1],[1,1]]] },
            S: { color: '#00f000', shape: [[[0,1,1],[1,1,0],[0,0,0]], [[0,1,0],[0,1,1],[0,0,1]], [[0,0,0],[0,1,1],[1,1,0]], [[1,0,0],[1,1,0],[0,1,0]]] },
            T: { color: '#a000f0', shape: [[[0,1,0],[1,1,1],[0,0,0]], [[0,1,0],[0,1,1],[0,1,0]], [[0,0,0],[1,1,1],[0,1,0]], [[0,1,0],[1,1,0],[0,1,0]]] },
            Z: { color: '#f00000', shape: [[[1,1,0],[0,1,1],[0,0,0]], [[0,0,1],[0,1,1],[0,1,0]], [[0,0,0],[1,1,0],[0,1,1]], [[0,1,0],[1,1,0],[1,0,0]]] }
        };
        const KICKS = {
            JLSTZ: {
                '0-1': [[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]], '1-0': [[0,0],[1,0],[1,-1],[0,2],[1,2]],
                '1-2': [[0,0],[1,0],[1,-1],[0,2],[1,2]], '2-1': [[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],
                '2-3': [[0,0],[1,0],[1,1],[0,-2],[1,-2]], '3-2': [[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],
                '3-0': [[0,0],[-1,0],[-1,-1],[0,2],[-1,2]], '0-3': [[0,0],[1,0],[1,1],[0,-2],[1,-2]]
            },
            I: {
                '0-1': [[0,0],[-2,0],[1,0],[-2,-1],[1,2]], '1-0': [[0,0],[2,0],[-1,0],[2,1],[-1,-2]],
                '1-2': [[0,0],[-1,0],[2,0],[-1,2],[2,-1]], '2-1': [[0,0],[1,0],[-2,0],[1,-2],[-2,1]],
                '2-3': [[0,0],[2,0],[-1,0],[2,1],[-1,-2]], '3-2': [[0,0],[-2,0],[1,0],[-2,-1],[1,2]],
                '3-0': [[0,0],[1,0],[-2,0],[1,-2],[-2,1]], '0-3': [[0,0],[-1,0],[2,0],[-1,2],[2,-1]]
            }
        };
        // Seeded Random for Deterministic Pieces
        class Random {
            constructor(seed) { this.seed = seed; }
            next() { this.seed = (this.seed * 1103515245 + 12345) & 0x7fffffff; return this.seed / 0x7fffffff; }
            shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(this.next() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }
        }

        /**
         * INPUT HANDLER - THE CORE OF RESPONSIVE GAMEPLAY
         * Handles DAS, ARR, and Input Buffering
         */
        class InputHandler {
            constructor(game) {
                this.game = game;
                this.keys = new Map();
                this.dasTimer = 0;
                this.arrTimer = 0;
                this.currentDir = 0;
                // Buffers for IRS (Initial Rotation System) and IHS
                this.bufferedRotate = null;
                this.bufferedHold = false;
                
                window.addEventListener('keydown', e => this.onKeyDown(e));
                window.addEventListener('keyup', e => this.onKeyUp(e));
            }

            onKeyDown(e) {
                if (!this.game.running) return;
                if (!document.getElementById('settingsModal').classList.contains('hidden')) return; // Block input in menu
                
                // Prevent scrolling for game keys
                if (Object.values(keyMap).includes(e.key)) e.preventDefault();
                if (this.keys.get(e.key)) return;
                this.keys.set(e.key, true);

                // MOVEMENT (Left/Right)
                if (e.key === keyMap.LEFT || e.key === keyMap.RIGHT) {
                    const dir = e.key === keyMap.LEFT ? -1 : 1;
                    
                    if (this.currentDir !== dir) {
                        this.currentDir = dir;
                        this.dasTimer = 0;
                        this.arrTimer = 0;
                        this.game.move(dir); // Instant move on press
                    }
                }

                // ROTATION (Bufferable)
                if (e.key === keyMap.CW || e.key === keyMap.CCW || e.key === keyMap.R180) {
                    let dir = e.key === keyMap.CW ? 1 : (e.key === keyMap.CCW ? 3 : 2);
                    
                    // If piece exists, rotate. If not (delay state), buffer it.
                    if (this.game.piece) {
                        this.game.rotate(dir);
                    } else {
                        this.bufferedRotate = dir;
                    }
                }

                // HOLD (Bufferable)
                if (e.key === keyMap.HOLD) {
                    if (this.game.piece) {
                        this.game.hold();
                    } else {
                        this.bufferedHold = true;
                    }
                }
                
                // HARD DROP
                if (e.key === keyMap.HARD) {
                    if (this.game.piece) this.game.hardDrop();
                }
            }

            onKeyUp(e) {
                this.keys.set(e.key, false);
                if (e.key === keyMap.LEFT && this.currentDir === -1) this.currentDir = 0;
                if (e.key === keyMap.RIGHT && this.currentDir === 1) this.currentDir = 0;
            }

            update(dt) {
                if (!this.game.running) return;
                // Handle DAS/ARR
                if (this.currentDir !== 0) {
                    this.dasTimer += dt;
                    if (this.dasTimer >= this.game.settings.das) {
                        this.arrTimer += dt;
                        const arr = this.game.settings.arr;
                        
                        if (arr === 0) {
                            // Instant ARR
                            while(this.game.move(this.currentDir)) {}
                        } else {
                            while (this.arrTimer >= arr) {
                                this.game.move(this.currentDir);
                                this.arrTimer -= arr;
                            }
                        }
                    }
                }

                // Soft Drop
                if (this.keys.get(keyMap.SOFT) && this.game.piece) {
                    const factor = this.game.settings.sdf === 'inf' ? 20 : this.game.settings.sdf;
                    this.game.gravityTimer += dt * factor; 
                }
            }
            
            applyBuffer() {
                if (this.bufferedHold) {
                    this.game.hold();
                    this.bufferedHold = false;
                    this.bufferedRotate = null; 
                    return;
                }
                
                if (this.bufferedRotate !== null) {
                    this.game.rotate(this.bufferedRotate);
                    this.bufferedRotate = null;
                }
            }
        }

        /**
         * MAIN GAME LOGIC
         */
        class TetrisGame {
            constructor(id, seed, isLocal = false) {
                this.id = id;
                this.isLocal = isLocal;
                this.canvas = document.getElementById(`gameCanvas${id}`);
                this.ctx = this.canvas.getContext('2d');
                this.holdCtx = document.getElementById(`holdCanvas${id}`).getContext('2d');
                this.queueCtx = document.getElementById(`queueCanvas${id}`).getContext('2d');
                
                this.rng = new Random(seed);
                this.bag = [];
                this.board = Array(ROWS).fill(null).map(() => Array(COLS).fill(0));
                
                this.queue = [];
                this.holdPiece = null;
                this.canHold = true;
                this.piece = null;
                this.stats = { pps: 0, apm: 0, b2b: 0, combo: -1, pieces: 0, attacks: 0, start: 0 };
                // Settings are now loaded from the inputs
                this.settings = { 
                    arr: parseInt(document.getElementById('arrInput').value), 
                    das: parseInt(document.getElementById('dasInput').value), 
                    sdf: document.getElementById('sdfInput').value === 'inf' ? 'inf' : parseInt(document.getElementById('sdfInput').value) 
                };
                this.gravity = 1000; 
                this.gravityTimer = 0;
                this.lockDelay = 500;
                this.lockTimer = 0;
                this.lockMoves = 0;
                
                this.garbageQueue = [];
                this.running = false;

                if (isLocal) {
                    this.input = new InputHandler(this);
                }

                this.fillBag();
                this.fillQueue();
            }

            fillBag() {
                const pieces = ['I','J','L','O','S','T','Z'];
                this.bag.push(...this.rng.shuffle([...pieces]));
            }
            
            fillQueue() {
                while(this.queue.length < 5) {
                    if (this.bag.length === 0) this.fillBag();
                    this.queue.push(this.bag.shift());
                }
            }

            spawn() {
                if (this.bag.length === 0) this.fillBag();
                const type = this.queue.shift();
                this.fillQueue();
                
                this.piece = {
                    type: type,
                    x: type === 'O' ? 4 : 3,
                    y: type === 'I' ? -1 : 0, 
                    r: 0,
                    shape: SHAPES[type].shape[0],
                    lastKick: null
                };
                if (this.collide(0, 0, this.piece.shape)) {
                    this.gameOver();
                    return;
                }
                
                this.gravityTimer = 0;
                this.lockTimer = 0;
                this.lockMoves = 0;
                this.canHold = true;

                if (this.isLocal) {
                    // Refresh settings on spawn (in case they changed during game)
                    this.settings.arr = parseInt(document.getElementById('arrInput').value);
                    this.settings.das = parseInt(document.getElementById('dasInput').value);
                    const sdfVal = document.getElementById('sdfInput').value;
                    this.settings.sdf = sdfVal === 'inf' ? 'inf' : parseFloat(sdfVal);
                    
                    this.input.applyBuffer();
                }
                
                this.sendState();
            }

            rotate(dir) {
                if (!this.piece) return;
                const newR = (this.piece.r + dir) % 4;
                const nextShape = SHAPES[this.piece.type].shape[newR];
                
                const table = this.piece.type === 'I' ? KICKS.I : (this.piece.type === 'O' ? null : KICKS.JLSTZ);
                const kicks = table ? table[`${this.piece.r}-${newR}`] : [[0,0]];
                for (let k of kicks) {
                    if (!this.collide(k[0], -k[1], nextShape)) {
                        this.piece.x += k[0];
                        this.piece.y -= k[1];
                        this.piece.r = newR;
                        this.piece.shape = nextShape;
                        this.piece.lastKick = k;
                        this.onMove();
                        return;
                    }
                }
            }

            move(dir) {
                if (!this.piece) return false;
                if (!this.collide(dir, 0, this.piece.shape)) {
                    this.piece.x += dir;
                    this.onMove();
                    return true;
                }
                return false;
            }

            onMove() {
                if (this.lockMoves < 15 && this.isGround()) {
                    this.lockTimer = 0;
                    this.lockMoves++;
                }
            }

            isGround() {
                return this.collide(0, 1, this.piece.shape);
            }

            collide(dx, dy, shape) {
                for (let y = 0; y < shape.length; y++) {
                    for (let x = 0; x < shape[y].length; x++) {
                        if (shape[y][x]) {
                             const nx = this.piece.x + x + dx;
                             const ny = this.piece.y + y + dy;
                            if (nx < 0 || nx >= COLS || ny >= ROWS || (ny >= 0 && this.board[ny][nx])) return true;
                        }
                    }
                }
                return false;
            }

            hardDrop() {
                while (!this.collide(0, 1, this.piece.shape)) {
                    this.piece.y++;
                    this.stats.attacks += 0; 
                }
                this.lock();
            }
            
            hold() {
                if (!this.canHold) return;
                if (!this.holdPiece) {
                    this.holdPiece = this.piece.type;
                    this.spawn();
                } else {
                    const temp = this.holdPiece;
                    this.holdPiece = this.piece.type;
                    this.piece = {
                        type: temp,
                        x: temp === 'O' ? 4 : 3,
                        y: temp === 'I' ? -1 : 0,
                        r: 0,
                        shape: SHAPES[temp].shape[0]
                    };
                }
                this.canHold = false;
                this.lockTimer = 0;
                this.lockMoves = 0;
            }

            lock() {
                for (let y = 0; y < 4; y++) {
                    for (let x = 0; x < 4; x++) {
                        if (this.piece.shape[y][x]) {
                            const by = this.piece.y + y;
                            if (by >= 0) this.board[by][this.piece.x + x] = this.piece.type;
                        }
                    }
                }

                let tSpin = false;
                if (this.piece.type === 'T') {
                    let corners = 0;
                    [[0,0],[2,0],[0,2],[2,2]].forEach(([cx, cy]) => {
                        const bx = this.piece.x + cx;
                        const by = this.piece.y + cy;
                        if (bx<0 || bx>=COLS || by>=ROWS || (by>=0 && this.board[by][bx])) corners++;
                    });
                    if (corners >= 3) tSpin = true;
                }

                let lines = [];
                for (let r = 0; r < ROWS; r++) {
                    if (this.board[r].every(c => c !== 0)) lines.push(r);
                }

                let sent = 0;
                if (lines.length > 0) {
                    lines.forEach(idx => {
                        this.board.splice(idx, 1);
                        this.board.unshift(Array(COLS).fill(0));
                    });
                    const count = lines.length;
                    let atk = [0, 0, 1, 2, 4][count]; 
                    if (tSpin) atk = [0, 2, 4, 6][count];
                    if (this.board.every(r => r.every(c => c===0))) atk = 10;

                    const b2b = (tSpin || count === 4);
                    if (b2b) {
                        if (this.stats.b2b > 0) atk += 1;
                        this.stats.b2b++;
                    } else if (count > 0) {
                        this.stats.b2b = 0;
                    }
                    
                    this.stats.combo++;
                    if (this.stats.combo > 0) atk += Math.min(this.stats.combo, 4);
                    
                    while (atk > 0 && this.garbageQueue.length > 0) {
                        if (this.garbageQueue[0] <= atk) {
                            atk -= this.garbageQueue.shift();
                        } else {
                            this.garbageQueue[0] -= atk;
                            atk = 0;
                        }
                    }
                    
                    sent = atk;
                } else {
                    this.stats.combo = -1;
                    this.addGarbage();
                }

                this.stats.pieces++;
                if (sent > 0) {
                    this.stats.attacks += sent;
                    if (this.isLocal) sendNetworkData('attack', { lines: sent });
                }

                this.piece = null;
                this.spawn();
            }

            addGarbage() {
                if (this.garbageQueue.length === 0) return;
                let total = this.garbageQueue.reduce((a,b)=>a+b, 0);
                for (let i=0; i<total; i++) {
                    this.board.shift();
                    const line = Array(COLS).fill('G');
                    line[Math.floor(this.rng.next() * COLS)] = 0;
                    this.board.push(line);
                }
                this.garbageQueue = [];
                if (!this.board[0].every(c => c===0)) this.gameOver();
            }

            update(dt) {
                if (!this.running || !this.isLocal) return;
                this.input.update(dt);

                if (this.piece) {
                    this.gravityTimer += dt;
                    if (this.gravityTimer >= this.gravity) {
                        this.gravityTimer = 0;
                        if (!this.move(0, 1)) {}
                    }

                    if (this.isGround()) {
                        this.lockTimer += dt;
                        if (this.lockTimer >= this.lockDelay) {
                            this.lock();
                        }
                    }
                }
                
                const time = (Date.now() - this.stats.start) / 1000;
                document.getElementById(`pps${this.id}`).innerText = (this.stats.pieces / time).toFixed(2);
                document.getElementById(`apm${this.id}`).innerText = (this.stats.attacks / time * 60).toFixed(2);
            }

            draw() {
                this.ctx.fillStyle = '#0a0e27';
                this.ctx.fillRect(0, 0, 320, 640);
                
                this.ctx.strokeStyle = 'rgba(255,255,255,0.05)';
                this.ctx.lineWidth = 1;
                for(let x=0;x<=10;x++){this.ctx.beginPath();this.ctx.moveTo(x*BLOCK,0);this.ctx.lineTo(x*BLOCK,640);this.ctx.stroke();}
                for(let y=0;y<=20;y++){this.ctx.beginPath();this.ctx.moveTo(0,y*BLOCK);this.ctx.lineTo(320,y*BLOCK);this.ctx.stroke();}

                for (let y=0; y<ROWS; y++) {
                    for (let x=0; x<COLS; x++) {
                        if (this.board[y][x]) this.drawBlock(this.ctx, x, y, this.board[y][x]);
                    }
                }

                if (this.piece) {
                    let gy = this.piece.y;
                    while (!this.collide(0, gy - this.piece.y + 1, this.piece.shape)) gy++;
                    this.drawPiece(this.ctx, this.piece.x, gy, this.piece.shape, this.piece.type, 0.2);
                    this.drawPiece(this.ctx, this.piece.x, this.piece.y, this.piece.shape, this.piece.type, 1);
                }

                this.holdCtx.clearRect(0,0,80,80);
                if (this.holdPiece) this.drawPreview(this.holdCtx, this.holdPiece);

                this.queueCtx.clearRect(0,0,80,480);
                this.queue.forEach((p, i) => this.drawPreview(this.queueCtx, p, i * 80));
            }

            drawBlock(ctx, x, y, type, alpha=1) {
                const color = type === 'G' ? '#666' : SHAPES[type].color;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = color;
                ctx.fillRect(x*BLOCK+1, y*BLOCK+1, BLOCK-2, BLOCK-2);
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.fillRect(x*BLOCK+1, y*BLOCK+1, BLOCK-2, 6);
                ctx.globalAlpha = 1;
            }

            drawPiece(ctx, x, y, shape, type, alpha) {
                for (let r=0; r<shape.length; r++) {
                    for (let c=0; c<shape[r].length; c++) {
                        if (shape[r][c]) this.drawBlock(ctx, x+c, y+r, type, alpha);
                    }
                }
            }

            drawPreview(ctx, type, yOffset=0) {
                const shape = SHAPES[type].shape[0];
                const color = SHAPES[type].color;
                const size = 16;
                const ox = (80 - shape[0].length*size)/2;
                const oy = yOffset + (80 - shape.length*size)/2;
                
                for(let r=0; r<shape.length; r++){
                    for(let c=0; c<shape[r].length; c++){
                        if(shape[r][c]) {
                            ctx.fillStyle = color;
                            ctx.fillRect(ox+c*size, oy+r*size, size-1, size-1);
                        }
                    }
                }
            }
            
            gameOver() {
                this.running = false;
                addLog('GAME OVER', 'System');
                if (this.isLocal) sendNetworkData('gameOver', {});
            }

            receiveState(state) {
                this.board = state.board;
                this.piece = state.piece;
                this.holdPiece = state.holdPiece;
                this.queue = state.queue;
                this.stats = state.stats;
            }

            sendState() {
                if (!this.isLocal || !conn) return;
                sendNetworkData('state', {
                    board: this.board,
                    piece: this.piece,
                    holdPiece: this.holdPiece,
                    queue: this.queue,
                    stats: this.stats
                });
            }
        }

        /**
         * NETWORKING & GLOBAL LOOP
         */
        let peer, conn, myId;
        let player1, player2;
        let lastTime = 0;
        let accumulator = 0;
        const STEP = 1000/60;
        function init() {
            peer = new Peer({ config: { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] } });
            peer.on('open', id => {
                myId = id;
                document.getElementById('peerIdDisplay').innerText = id;
                document.getElementById('myPeerId').classList.remove('hidden');
                addLog(`Your ID: ${id}`);
            });
            peer.on('connection', c => {
                conn = c;
                setupConnection();
                addLog("Connected! Press START GAME to begin.");
                // SHOW START BUTTON WHEN CONNECTED
                document.getElementById('startGameBtn').classList.remove('hidden');
            });
            updateKeyInputDisplays();
            requestAnimationFrame(loop);
        }

        function setupConnection() {
            conn.on('data', data => {
                if (data.type === 'start') {
                    document.getElementById('gameStatus').innerText = "Playing!";
                    document.getElementById('gameArea').classList.remove('hidden');
                    document.getElementById('restartBtn').classList.remove('hidden');
                    startMatch(data.seed);
                }
                if (data.type === 'state') if (player2) player2.receiveState(data.data);
                if (data.type === 'attack') if (player1) player1.garbageQueue.push(data.data.lines);
                if (data.type === 'chat') addLog(data.data, 'Opponent');
                if (data.type === 'gameOver') {
                    document.getElementById('gameStatus').innerText = "YOU WIN!";
                    addLog("Opponent topped out! You Win!", "System");
                    player1.running = false;
                }
            });
        }

        function sendNetworkData(type, data) {
            if (conn && conn.open) conn.send({ type, data });
        }

        document.getElementById('createGameBtn').onclick = () => {
            addLog("Waiting for opponent...");
            document.getElementById('createGameBtn').disabled = true;
        };

        // NEW START GAME BUTTON HANDLER
        document.getElementById('startGameBtn').onclick = () => {
            const seed = Date.now();
            sendNetworkData('start', { seed });
            startMatch(seed);
            document.getElementById('gameStatus').innerText = "Playing!";
            document.getElementById('gameArea').classList.remove('hidden');
            document.getElementById('startGameBtn').classList.add('hidden');
            document.getElementById('restartBtn').classList.remove('hidden');
        };

        document.getElementById('joinGameBtn').onclick = () => {
            let id = document.getElementById('opponentPeerId').value;
            if(!id) return;
            conn = peer.connect(id);
            setupConnection();
        };

        document.getElementById('restartBtn').onclick = () => {
            const seed = Date.now();
            sendNetworkData('start', { seed });
            startMatch(seed);
        };

        function startMatch(seed) {
            player1 = new TetrisGame(1, seed, true);
            player2 = new TetrisGame(2, seed, false); 
            player1.running = true;
            player1.stats.start = Date.now();
            player2.stats.start = Date.now();
            player1.spawn();
        }

        function loop(time) {
            const dt = time - lastTime;
            lastTime = time;

            if (player1 && player1.running) {
                player1.update(dt);
                player1.draw();
                if (Math.floor(time / 50) > Math.floor((time - dt) / 50)) {
                    player1.sendState();
                }
            }
            if (player2) player2.draw();
            requestAnimationFrame(loop);
        }

        // Chat
        function addLog(msg, from="System") {
            const div = document.createElement('div');
            div.innerHTML = `<span style="color:${from==='System'?'#ff0':'#0ff'}">${from}:</span> ${msg}`;
            document.getElementById('chatMessages').appendChild(div);
            document.getElementById('chatMessages').scrollTop = 99999;
        }
        document.getElementById('sendChatBtn').onclick = () => {
            let val = document.getElementById('chatInput').value;
            if(val) { sendNetworkData('chat', val); addLog(val, "Me"); document.getElementById('chatInput').value=''; }
        };
        function copyPeerId() {
            navigator.clipboard.writeText(myId);
            addLog("ID Copied");
        }

        // --- SETTINGS MODAL & BINDING LOGIC ---
        const settingsModal = document.getElementById('settingsModal');
        const settingsBtn = document.getElementById('settingsBtn');
        const closeSettingsBtn = document.getElementById('closeSettingsBtn');

        settingsBtn.onclick = () => settingsModal.classList.remove('hidden');
        closeSettingsBtn.onclick = () => settingsModal.classList.add('hidden');
        const bindMap = {
            'bindLeft': 'LEFT', 'bindRight': 'RIGHT', 'bindSoft': 'SOFT', 'bindHard': 'HARD',
            'bindCW': 'CW', 'bindCCW': 'CCW', 'bind180': 'R180', 'bindHold': 'HOLD'
        };
        function updateKeyInputDisplays() {
            for (let [id, key] of Object.entries(bindMap)) {
                let val = keyMap[key];
                if(val === " ") val = "Space";
                document.getElementById(id).value = val;
            }
        }

        for (let [id, action] of Object.entries(bindMap)) {
            const input = document.getElementById(id);
            input.onclick = () => {
                input.value = "Press key...";
                const handler = (e) => {
                    e.preventDefault();
                    keyMap[action] = e.key;
                    updateKeyInputDisplays();
                    document.removeEventListener('keydown', handler);
                };
                
                document.addEventListener('keydown', handler);
            };
        }

        init();
    </script>
</body>
</html>
