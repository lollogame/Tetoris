<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris Multiplayer - Optimized Edition</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Orbitron:wght@400;700;900&display=swap');
        
        :root {
            --bg-dark: #0a0e27;
            --bg-grid: #151b3d;
            --border-glow: #00ffff;
            --text-primary: #ffffff;
            --text-secondary: #8b9dc3;
            --accent-cyan: #00ffff;
            --accent-pink: #ff00ff;
            --accent-yellow: #ffff00;
            --shadow-glow: 0 0 20px rgba(0, 255, 255, 0.5);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Orbitron', monospace;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f4d 100%);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0, 255, 255, 0.03) 2px, rgba(0, 255, 255, 0.03) 4px),
                repeating-linear-gradient(90deg, transparent, transparent 2px, rgba(255, 0, 255, 0.03) 2px, rgba(255, 0, 255, 0.03) 4px);
            pointer-events: none;
            animation: scanlines 8s linear infinite;
        }
        
        @keyframes scanlines {
            0% { transform: translateY(0); }
            100% { transform: translateY(4px); }
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 1;
        }
        
        h1 {
            font-family: 'Press Start 2P', cursive;
            text-align: center;
            font-size: 2rem;
            margin-bottom: 30px;
            text-transform: uppercase;
            background: linear-gradient(45deg, var(--accent-cyan), var(--accent-pink), var(--accent-yellow));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 10px rgba(0, 255, 255, 0.5));
            animation: glow-pulse 2s ease-in-out infinite;
        }
        
        @keyframes glow-pulse {
            0%, 100% { filter: drop-shadow(0 0 10px rgba(0, 255, 255, 0.5)); }
            50% { filter: drop-shadow(0 0 20px rgba(255, 0, 255, 0.8)); }
        }
        
        .controls-panel {
            background: rgba(21, 27, 61, 0.8);
            border: 2px solid var(--border-glow);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: var(--shadow-glow);
        }
        
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .control-item {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .control-item label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            text-transform: uppercase;
        }
        
        .control-item input, .control-item select {
            background: rgba(10, 14, 39, 0.9);
            border: 1px solid var(--accent-cyan);
            color: var(--text-primary);
            padding: 8px;
            border-radius: 5px;
            font-family: 'Orbitron', monospace;
            font-size: 0.9rem;
        }
        
        .control-item input:focus, .control-item select:focus {
            outline: none;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        button {
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-pink));
            border: none;
            color: var(--bg-dark);
            padding: 12px 24px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.7rem;
            border-radius: 5px;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 255, 255, 0.3);
        }
        
        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 0, 255, 0.5);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .game-area {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin-top: 30px;
            flex-wrap: wrap;
        }
        
        .player-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        
        .player-header {
            font-family: 'Press Start 2P', cursive;
            font-size: 1rem;
            color: var(--accent-cyan);
            text-shadow: 0 0 10px var(--accent-cyan);
        }
        
        .game-wrapper {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }
        
        .side-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .info-box {
            background: rgba(21, 27, 61, 0.9);
            border: 2px solid var(--accent-cyan);
            border-radius: 8px;
            padding: 15px;
            min-width: 150px;
            box-shadow: var(--shadow-glow);
        }
        
        .info-box h3 {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.6rem;
            margin-bottom: 10px;
            color: var(--accent-yellow);
            text-align: center;
        }
        
        .stat {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 0.9rem;
        }
        
        .stat-label {
            color: var(--text-secondary);
            font-size: 0.75rem;
        }
        
        .stat-value {
            color: var(--accent-cyan);
            font-weight: bold;
        }
        
        .canvas-container {
            position: relative;
            border: 3px solid var(--border-glow);
            border-radius: 5px;
            box-shadow: 
                var(--shadow-glow),
                inset 0 0 20px rgba(0, 255, 255, 0.1);
            background: rgba(10, 14, 39, 0.95);
        }
        
        canvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        .mini-canvas-container {
            background: rgba(10, 14, 39, 0.9);
            border: 2px solid var(--accent-pink);
            border-radius: 5px;
            padding: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100px;
        }
        
        .chat-container {
            background: rgba(21, 27, 61, 0.9);
            border: 2px solid var(--border-glow);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            box-shadow: var(--shadow-glow);
        }
        
        .chat-messages {
            height: 150px;
            overflow-y: auto;
            background: rgba(10, 14, 39, 0.8);
            border: 1px solid var(--accent-cyan);
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 10px;
            font-size: 0.85rem;
        }
        
        .chat-message {
            margin: 5px 0;
            padding: 5px;
            border-left: 2px solid var(--accent-pink);
            padding-left: 8px;
        }
        
        .chat-input-container {
            display: flex;
            gap: 10px;
        }
        
        .chat-input {
            flex: 1;
            background: rgba(10, 14, 39, 0.9);
            border: 1px solid var(--accent-cyan);
            color: var(--text-primary);
            padding: 10px;
            border-radius: 5px;
            font-family: 'Orbitron', monospace;
        }
        
        .connection-panel {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .connection-panel input {
            background: rgba(10, 14, 39, 0.9);
            border: 1px solid var(--accent-cyan);
            color: var(--text-primary);
            padding: 10px;
            border-radius: 5px;
            font-family: 'Orbitron', monospace;
            width: 300px;
        }
        
        #gameStatus {
            text-align: center;
            margin-top: 20px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
            color: var(--accent-yellow);
            text-shadow: 0 0 10px var(--accent-yellow);
        }
        
        #myPeerId {
            background: rgba(21, 27, 61, 0.9);
            border: 2px solid var(--accent-cyan);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 20px;
            box-shadow: var(--shadow-glow);
        }
        
        #myPeerId .peer-id-label {
            font-size: 0.7rem;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }
        
        #myPeerId .peer-id-value {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.9rem;
            color: var(--accent-cyan);
            word-break: break-all;
            user-select: all;
            cursor: pointer;
            padding: 10px;
            background: rgba(10, 14, 39, 0.8);
            border-radius: 5px;
            border: 1px solid var(--accent-pink);
        }
        
        .hidden {
            display: none !important;
        }

        .copy-btn {
            margin-top: 10px;
            font-size: 0.6rem;
            padding: 8px 16px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>â¬› Tetris Online Battle â¬›</h1>
        
        <div class="controls-panel">
            <h2 style="font-family: 'Press Start 2P', cursive; font-size: 1rem; margin-bottom: 15px; text-align: center;">Game Settings</h2>
            
            <div class="controls-grid">
                <div class="control-item">
                    <label>Move Left</label>
                    <input type="text" id="keyLeft" value="ArrowLeft" readonly>
                </div>
                <div class="control-item">
                    <label>Move Right</label>
                    <input type="text" id="keyRight" value="ArrowRight" readonly>
                </div>
                <div class="control-item">
                    <label>Soft Drop</label>
                    <input type="text" id="keySoftDrop" value="ArrowDown" readonly>
                </div>
                <div class="control-item">
                    <label>Hard Drop</label>
                    <input type="text" id="keyHardDrop" value=" " readonly>
                </div>
                <div class="control-item">
                    <label>Rotate CW</label>
                    <input type="text" id="keyRotateCW" value="ArrowUp" readonly>
                </div>
                <div class="control-item">
                    <label>Rotate CCW</label>
                    <input type="text" id="keyRotateCCW" value="z" readonly>
                </div>
                <div class="control-item">
                    <label>Rotate 180</label>
                    <input type="text" id="keyRotate180" value="x" readonly>
                </div>
                <div class="control-item">
                    <label>Hold Piece</label>
                    <input type="text" id="keyHold" value="c" readonly>
                </div>
                <div class="control-item">
                    <label>ARR (ms)</label>
                    <input type="number" id="arr" value="0" min="0" max="200">
                </div>
                <div class="control-item">
                    <label>DAS (ms)</label>
                    <input type="number" id="das" value="167" min="0" max="500">
                </div>
                <div class="control-item">
                    <label>DCD (ms)</label>
                    <input type="number" id="dcd" value="0" min="0" max="100">
                </div>
                <div class="control-item">
                    <label>SDF (multiplier)</label>
                    <select id="sdf">
                        <option value="1">1x</option>
                        <option value="2">2x</option>
                        <option value="6" selected>6x</option>
                        <option value="10">10x</option>
                        <option value="20">20x</option>
                        <option value="inf">Infinite</option>
                    </select>
                </div>
                <div class="control-item">
                    <label>Prevent Missdrop</label>
                    <select id="preventMissdrop">
                        <option value="true" selected>On</option>
                        <option value="false">Off</option>
                    </select>
                </div>
            </div>
            
            <div style="text-align: center; margin-top: 15px; color: var(--text-secondary); font-size: 0.75rem;">
                Click on any key binding to change it
            </div>
        </div>
        
        <div id="myPeerId" class="hidden">
            <div class="peer-id-label">YOUR PEER ID (share this with your opponent):</div>
            <div class="peer-id-value" id="peerIdDisplay" onclick="window.copyPeerId()">Connecting...</div>
            <button class="copy-btn" onclick="window.copyPeerId()">ðŸ“‹ Copy ID</button>
        </div>
        
        <div class="connection-panel">
            <button id="createGameBtn">Create Game</button>
            <input type="text" id="opponentPeerId" placeholder="Enter opponent's Peer ID to join">
            <button id="joinGameBtn">Join Game</button>
            <button id="restartBtn" class="hidden">Restart Game</button>
        </div>
        
        <div id="gameStatus">Click "Create Game" to host or enter a Peer ID to join</div>
        
        <div class="game-area hidden" id="gameArea">
            <div class="player-container">
                <div class="player-header">ðŸŽ® YOU</div>
                <div class="game-wrapper">
                    <div class="side-panel">
                        <div class="info-box">
                            <h3>HOLD</h3>
                            <div class="mini-canvas-container">
                                <canvas id="holdCanvas1" width="80" height="80"></canvas>
                            </div>
                        </div>
                        <div class="info-box">
                            <h3>STATS</h3>
                            <div class="stat">
                                <span class="stat-label">PPS:</span>
                                <span class="stat-value" id="pps1">0.00</span>
                            </div>
                            <div class="stat">
                                <span class="stat-label">APM:</span>
                                <span class="stat-value" id="apm1">0.00</span>
                            </div>
                            <div class="stat">
                                <span class="stat-label">B2B:</span>
                                <span class="stat-value" id="b2b1">0</span>
                            </div>
                            <div class="stat">
                                <span class="stat-label">Combo:</span>
                                <span class="stat-value" id="combo1">0</span>
                            </div>
                        </div>
                    </div>
                    <div class="canvas-container">
                        <canvas id="gameCanvas1" width="320" height="640"></canvas>
                    </div>
                    <div class="side-panel">
                        <div class="info-box">
                            <h3>NEXT</h3>
                            <div class="mini-canvas-container">
                                <canvas id="queueCanvas1" width="80" height="480"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="player-container">
                <div class="player-header">ðŸŽ® OPPONENT</div>
                <div class="game-wrapper">
                    <div class="side-panel">
                        <div class="info-box">
                            <h3>HOLD</h3>
                            <div class="mini-canvas-container">
                                <canvas id="holdCanvas2" width="80" height="80"></canvas>
                            </div>
                        </div>
                        <div class="info-box">
                            <h3>STATS</h3>
                            <div class="stat">
                                <span class="stat-label">PPS:</span>
                                <span class="stat-value" id="pps2">0.00</span>
                            </div>
                            <div class="stat">
                                <span class="stat-label">APM:</span>
                                <span class="stat-value" id="apm2">0.00</span>
                            </div>
                            <div class="stat">
                                <span class="stat-label">B2B:</span>
                                <span class="stat-value" id="b2b2">0</span>
                            </div>
                            <div class="stat">
                                <span class="stat-label">Combo:</span>
                                <span class="stat-value" id="combo2">0</span>
                            </div>
                        </div>
                    </div>
                    <div class="canvas-container">
                        <canvas id="gameCanvas2" width="320" height="640"></canvas>
                    </div>
                    <div class="side-panel">
                        <div class="info-box">
                            <h3>NEXT</h3>
                            <div class="mini-canvas-container">
                                <canvas id="queueCanvas2" width="80" height="480"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="chat-container">
            <h3 style="font-family: 'Press Start 2P', cursive; font-size: 0.8rem; margin-bottom: 10px; text-align: center; color: var(--accent-yellow);">ðŸ’¬ CHAT</h3>
            <div class="chat-messages" id="chatMessages"></div>
            <div class="chat-input-container">
                <input type="text" class="chat-input" id="chatInput" placeholder="Type a message...">
                <button id="sendChatBtn">Send</button>
            </div>
        </div>
    </div>
    
    <script>
        'use strict';
        
        // Constants
        const COLS = 10;
        const ROWS = 20;
        const SPAWN_ROW = -2;
        const BLOCK_SIZE = 32;
        const PREVIEW_BLOCK_SIZE = 16;
        const ROTATION_BUFFER_MS = 120;
        const STATE_SEND_INTERVAL = 50;
        const ROTATION_STATES = ['0', 'R', '2', 'L'];
        
        // SRS Kick Tables
        const KICK_TABLE = {
            JLSTZ: {
                '0->R': [[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],
                'R->0': [[0,0],[1,0],[1,-1],[0,2],[1,2]],
                'R->2': [[0,0],[1,0],[1,-1],[0,2],[1,2]],
                '2->R': [[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],
                '2->L': [[0,0],[1,0],[1,1],[0,-2],[1,-2]],
                'L->2': [[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],
                'L->0': [[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],
                '0->L': [[0,0],[1,0],[1,1],[0,-2],[1,-2]]
            },
            I: {
                '0->R': [[0,0],[-2,0],[1,0],[-2,-1],[1,2]],
                'R->0': [[0,0],[2,0],[-1,0],[2,1],[-1,-2]],
                'R->2': [[0,0],[-1,0],[2,0],[-1,2],[2,-1]],
                '2->R': [[0,0],[1,0],[-2,0],[1,-2],[-2,1]],
                '2->L': [[0,0],[2,0],[-1,0],[2,1],[-1,-2]],
                'L->2': [[0,0],[-2,0],[1,0],[-2,-1],[1,2]],
                'L->0': [[0,0],[1,0],[-2,0],[1,-2],[-2,1]],
                '0->L': [[0,0],[-1,0],[2,0],[-1,2],[2,-1]]
            },
            O: {
                '0->R': [[0,0]],
                'R->2': [[0,0]],
                '2->L': [[0,0]],
                'L->0': [[0,0]],
                'R->0': [[0,0]],
                '2->R': [[0,0]],
                'L->2': [[0,0]],
                '0->L': [[0,0]]
            }
        };
        
        // Piece definitions
        const PIECES = {
            I: [
                [0,0,0,0],
                [1,1,1,1],
                [0,0,0,0],
                [0,0,0,0]
            ],
            J: [
                [1,0,0],
                [1,1,1],
                [0,0,0]
            ],
            L: [
                [0,0,1],
                [1,1,1],
                [0,0,0]
            ],
            O: [
                [1,1],
                [1,1]
            ],
            S: [
                [0,1,1],
                [1,1,0],
                [0,0,0]
            ],
            T: [
                [0,1,0],
                [1,1,1],
                [0,0,0]
            ],
            Z: [
                [1,1,0],
                [0,1,1],
                [0,0,0]
            ]
        };
        
        // Colors
        const COLORS = {
            I: '#00f0f0',
            J: '#0000f0',
            L: '#f0a000',
            O: '#f0f000',
            S: '#00f000',
            T: '#a000f0',
            Z: '#f00000',
            ghost: 'rgba(255,255,255,0.2)',
            grid: 'rgba(255,255,255,0.05)',
            background: '#0a0e27'
        };
        
        // Spawn positions for each piece
        const SPAWN_COLUMNS = {
            I: 3,
            J: 3,
            L: 3,
            O: 4,
            S: 3,
            T: 3,
            Z: 3
        };
        
        // Scoring constants
        const SCORE_TABLE = {
            single: 100,
            double: 300,
            triple: 500,
            tetris: 800,
            tspin_mini: 100,
            tspin_single: 800,
            tspin_double: 1200,
            tspin_triple: 1600,
            perfect_clear: 3500
        };
        
        // Attack table for multiplayer
        const ATTACK_TABLE = {
            single: 0,
            double: 1,
            triple: 2,
            tetris: 4,
            tspin_mini: 0,
            tspin_single: 2,
            tspin_double: 4,
            tspin_triple: 6,
            perfect_clear: 10
        };
        
        // Chat manager
        class ChatManager {
            static addMessage(message, isSystem = true) {
                const chatMessages = document.getElementById('chatMessages');
                const messageElement = document.createElement('div');
                messageElement.className = `chat-message ${isSystem ? 'system' : 'player'}`;
                messageElement.textContent = message;
                chatMessages.appendChild(messageElement);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }
        }
        
        // Game settings
        class GameSettings {
            static instance = null;
            
            constructor() {
                this.das = 100;
                this.arr = 50;
                this.dcd = 50;
                this.lockDelay = 500;
                this.maxLockResets = 15;
                this.gravity = 1000;
                this.softDropMultiplier = 20;
                this.level = 1;
            }
            
            static getInstance() {
                if (!GameSettings.instance) {
                    GameSettings.instance = new GameSettings();
                }
                return GameSettings.instance;
            }
            
            updateFromUI() {
  const dasEl = document.getElementById("das");
  const arrEl = document.getElementById("arr");
  const dcdEl = document.getElementById("dcd");
  const sdfEl = document.getElementById("sdf");

  if (dasEl) this.das = parseInt(dasEl.value, 10) || 0;
  if (arrEl) this.arr = parseInt(arrEl.value, 10) || 0;
  if (dcdEl) this.dcd = parseInt(dcdEl.value, 10) || 0;

  // SDF is a multiplier; "inf" means basically instant soft drop
  if (sdfEl) {
    if (sdfEl.value === "inf") this.softDropMultiplier = 999999;
    else this.softDropMultiplier = parseInt(sdfEl.value, 10) || 1;
  }
}

        
        // Network manager
        class NetworkManager {
  static instance = null;

  constructor() {
    this.peer = null;
    this.conn = null;
    this.isHost = false;
    this.messageHandler = null;

    this.roomCode = null;
    this._connecting = false;
  }

  static getInstance() {
    if (!NetworkManager.instance) NetworkManager.instance = new NetworkManager();
    return NetworkManager.instance;
  }

  // ---- utilities ----
  static makeRoomCode(len = 6) {
    const alphabet = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789"; // no 0/O/1/I confusion
    let out = "";
    for (let i = 0; i < len; i++) out += alphabet[(Math.random() * alphabet.length) | 0];
    return out;
  }

  static peerOptions() {
    return {
      debug: 2,
      config: {
        iceServers: [
          { urls: "stun:stun.l.google.com:19302" },
          { urls: "stun:stun1.l.google.com:19302" }
        ]
      }
    };
  }

  _setStatus(text) {
    const el = document.getElementById("gameStatus");
    if (el) el.textContent = text;
  }

  _showMyCode(code) {
    const box = document.getElementById("myPeerId");
    const val = document.getElementById("peerIdDisplay");
    if (box) box.classList.remove("hidden");
    if (val) val.textContent = code;
  }

  _cleanup() {
    try { if (this.conn) this.conn.close(); } catch {}
    try { if (this.peer) this.peer.destroy(); } catch {}
    this.peer = null;
    this.conn = null;
    this.isHost = false;
    this.roomCode = null;
    this._connecting = false;
  }

  initialize(messageHandler) {
    this.messageHandler = messageHandler;
  }

  // ---- host ----
  async host() {
    if (this._connecting) return;
    this._connecting = true;

    this._cleanup();
    this.isHost = true;

    // Try multiple codes in case one is taken
    for (let attempt = 0; attempt < 10; attempt++) {
      const code = NetworkManager.makeRoomCode(6);
      this._setStatus(`Creating room ${code}...`);
      const ok = await this._tryCreatePeerWithId(code);
      if (ok) {
        this.roomCode = code;
        this._showMyCode(code);
        this._setStatus(`Room ${code} created. Waiting for opponent...`);
        this._connecting = false;
        return;
      }
    }

    this._setStatus("Failed to create room (IDs taken). Try again.");
    this._connecting = false;
  }

  _tryCreatePeerWithId(code) {
    return new Promise((resolve) => {
      const peer = new Peer(code, NetworkManager.peerOptions());
      let done = false;

      const finish = (result) => {
        if (done) return;
        done = true;
        resolve(result);
      };

      peer.on("open", () => {
        this.peer = peer;

        // wait for opponent
        peer.on("connection", (conn) => {
          // accept only first connection
          if (this.conn) {
            try { conn.close(); } catch {}
            return;
          }
          this.conn = conn;
          this._setupConnectionHandlers();
          this._setStatus("Opponent connected! Starting game...");
          // auto-start both sides
          this.send({ type: "startGame", seed: (Math.random() * 1e9) | 0 });
          if (this.messageHandler) this.messageHandler({ type: "startGame" });
        });

        finish(true);
      });

      peer.on("error", (err) => {
        // ID taken: try another
        if (err && err.type === "unavailable-id") {
          try { peer.destroy(); } catch {}
          finish(false);
          return;
        }
        console.error("Peer error (host):", err);
        try { peer.destroy(); } catch {}
        finish(false);
      });

      // timeout so it doesn't hang forever
      setTimeout(() => {
        try { peer.destroy(); } catch {}
        finish(false);
      }, 4000);
    });
  }

  // ---- join ----
  join(codeRaw) {
    if (this._connecting) return;
    this._connecting = true;

    const code = (codeRaw || "").trim().toUpperCase();
    if (!code) {
      this._setStatus("Enter a room code first.");
      this._connecting = false;
      return;
    }

    this._cleanup();
    this.isHost = false;
    this.roomCode = code;

    this._setStatus(`Joining room ${code}...`);

    this.peer = new Peer(undefined, NetworkManager.peerOptions());

    this.peer.on("open", () => {
      this._setStatus(`Connecting to host ${code}...`);

      this.conn = this.peer.connect(code, { reliable: true });

      this.conn.on("open", () => {
        this._setupConnectionHandlers();
        this._setStatus("Connected! Waiting for host to start...");
        this._connecting = false;
      });

      this.conn.on("error", (err) => {
        console.error("Conn error (join):", err);
        this._setStatus(`Connection error: ${err?.type || err}`);
        this._connecting = false;
      });
    });

    this.peer.on("error", (err) => {
      console.error("Peer error (join):", err);
      this._setStatus(`Peer error: ${err?.type || err}`);
      this._connecting = false;
    });
  }

  _setupConnectionHandlers() {
    if (!this.conn) return;

    this.conn.on("data", (data) => {
      if (this.messageHandler) this.messageHandler(data);
    });

    this.conn.on("close", () => {
      this._setStatus("Disconnected.");
      this.conn = null;
    });

    this.conn.on("error", (err) => {
      console.error("Datachannel error:", err);
      this._setStatus(`Datachannel error: ${err?.type || err}`);
    });
  }

  // ---- send helpers used by your game loop ----
  send(data) {
    if (this.conn && this.conn.open) this.conn.send(data);
  }

  sendGameState(state) {
    this.send({ type: "gameState", state });
  }

  sendAttack(lines) {
    const capped = Math.min(lines, 12);
    this.send({ type: "attack", lines: capped });
  }

  isConnected() {
    return !!(this.conn && this.conn.open);
  }
}



        
        class InputManager {
    static instance = null;

    constructor() {
        this.heldKeys = {};

        this.keyBindings = {
            left: 'ArrowLeft',
            right: 'ArrowRight',
            softDrop: 'ArrowDown',
            hardDrop: 'Space',
            hold: 'Shift',
            rotateCW: 'ArrowUp',
            rotateCCW: 'z',
            rotate180: 'x'
        };

        this.move = {
            left: false,
            right: false,
            direction: 0,
            lastDirection: 0,
            dasTimer: 0,
            arrTimer: 0,
            dcdTimer: 0
        };

        this.onMoveImmediate = null;
    }

    static getInstance() {
        if (!InputManager.instance) {
            InputManager.instance = new InputManager();
        }
        return InputManager.instance;
    }

    setupKeyBindings() {
        const customBindings = localStorage.getItem('tetrisKeyBindings');
        if (customBindings) {
            this.keyBindings = JSON.parse(customBindings);
            this.updateKeyBindingUI();
        }
    }

    updateKeyBindingUI() {
        document.getElementById('keyLeft').value = this.keyBindings.left;
        document.getElementById('keyRight').value = this.keyBindings.right;
        document.getElementById('keySoftDrop').value = this.keyBindings.softDrop;
        document.getElementById('keyHardDrop').value = this.keyBindings.hardDrop;
        document.getElementById('keyHold').value = this.keyBindings.hold;
        document.getElementById('keyRotateCW').value = this.keyBindings.rotateCW;
        document.getElementById('keyRotateCCW').value = this.keyBindings.rotateCCW;
        document.getElementById('keyRotate180').value = this.keyBindings.rotate180;
    }

    saveKeyBindings() {
        localStorage.setItem('tetrisKeyBindings', JSON.stringify(this.keyBindings));
    }

    setKeyBinding(action, key) {
        this.keyBindings[action] = key;
        this.saveKeyBindings();
    }

    getKeyBindings() {
        return this.keyBindings;
    }

    getHeldKeys() {
        return this.heldKeys;
    }

    handleKeyDown(key) {
        this.heldKeys[key] = true;

        if (key === this.keyBindings.left) {
            this.move.left = true;
            this.move.direction = -1;
            if (this.move.lastDirection !== -1) {
                this.move.dcdTimer = GameSettings.getInstance().dcd;
            }
            this.move.lastDirection = -1;
        } else if (key === this.keyBindings.right) {
            this.move.right = true;
            this.move.direction = 1;
            if (this.move.lastDirection !== 1) {
                this.move.dcdTimer = GameSettings.getInstance().dcd;
            }
            this.move.lastDirection = 1;
        }
    }

    handleKeyUp(key) {
        delete this.heldKeys[key];

        if (key === this.keyBindings.left) {
            this.move.left = false;
            this.move.direction = this.move.right ? 1 : 0;
            this.move.lastDirection = this.move.direction;
            this.move.dcdTimer = GameSettings.getInstance().dcd;
        } else if (key === this.keyBindings.right) {
            this.move.right = false;
            this.move.direction = this.move.left ? -1 : 0;
            this.move.lastDirection = this.move.direction;
            this.move.dcdTimer = GameSettings.getInstance().dcd;
        }
    }

    update(deltaTime, moveFn) {
        const settings = GameSettings.getInstance();

        if (this.move.dcdTimer > 0) {
            this.move.dcdTimer -= deltaTime;
            return;
        }

        if (this.move.direction === 0) return;

        this.move.dasTimer += deltaTime;

        if (this.move.dasTimer === deltaTime) {
            moveFn(this.move.direction);
        }

        if (this.move.dasTimer >= settings.das) {
            this.move.arrTimer += deltaTime;

            if (this.move.arrTimer >= settings.arr) {
                moveFn(this.move.direction);
                this.move.arrTimer = 0;
            }
        }
    }

    reset() {
        this.move = {
            left: false,
            right: false,
            direction: 0,
            lastDirection: 0,
            dasTimer: 0,
            arrTimer: 0,
            dcdTimer: 0
        };
        this.heldKeys = {};
    }
            resetOnSpawn() {
    this.resetMovementOnSpawn();
}
            resetMovementOnSpawn() {
    this.move.dasTimer = 0;
    this.move.arrTimer = 0;
    this.move.dcdTimer = GameSettings.getInstance().dcd;

    // Re-trigger immediate movement if a direction is held
    if (this.move.direction !== 0 && this.onMoveImmediate) {
        this.onMoveImmediate(this.move.direction);
    }
}

}

        
        // =======================================
        // Tetris game state
        // =======================================
        class TetrisGameState {
            constructor(canvasId, holdCanvasId, queueCanvasId, isPlayerOne = true) {
                this.isPlayerOne = isPlayerOne;
                this.grid = Array(ROWS).fill().map(() => Array(COLS).fill(null));
                this.currentPiece = null;
                this.currentX = 0;
                this.currentY = 0;
                this.currentRotation = 0;
                this.ghostY = 0;
                
                this.holdPiece = null;
                this.canHold = true;
                this.queue = [];
                
                this.score = 0;
                this.lines = 0;
                this.level = 1;
                this.gameOver = false;
                
                this.lockDelayTimer = 0;
                this.lockResetCount = 0;
                this.isTouchingGround = false;
                this.lockDelay = GameSettings.getInstance().lockDelay;
                this.maxLockResets = GameSettings.getInstance().maxLockResets;
                
                this.gravityTimer = 0;
                this.hardDropCooldown = 0;
                this.hardDropCooldownFrames = 10;
                this.dcdTimer = 0;
                
                this.piecesPlaced = 0;
                this.attacksSent = 0;
                this.b2bCounter = 0;
                this.comboCounter = -1;
                this.lastClearWasB2B = false;
                
                this.lastActionWasRotation = false;
                this.rotateBuffer = null;
                this.spawnGrace = false;
                this.spawnGraceUsed = false;
                this.softDropActive = false;
                
                this.pendingGarbage = [];
                
                const canvas = document.getElementById(canvasId);
                const holdCanvas = document.getElementById(holdCanvasId);
                const queueCanvas = document.getElementById(queueCanvasId);
                
                this.renderer = new TetrisRenderer(canvas, holdCanvas, queueCanvas);
                
                this.initQueue();
                this.spawnPiece();
            }
            
            initQueue() {
                const pieces = ['I', 'J', 'L', 'O', 'S', 'T', 'Z'];
                let bag = [...pieces];
                
                while (this.queue.length < 14) {
                    if (bag.length === 0) bag = [...pieces];
                    const idx = Math.floor(Math.random() * bag.length);
                    this.queue.push(bag.splice(idx, 1)[0]);
                }
            }
            
            getNextPiece() {
                const pieces = ['I', 'J', 'L', 'O', 'S', 'T', 'Z'];
                if (!this.bag || this.bag.length === 0) {
                    this.bag = [...pieces];
                    // Fisher-Yates shuffle
                    for (let i = this.bag.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [this.bag[i], this.bag[j]] = [this.bag[j], this.bag[i]];
                    }
                }
                return this.bag.pop();
            }
            
            resetPieceState(piece) {
                this.currentPiece = piece;
                this.currentRotation = 0;
                this.currentX = SPAWN_COLUMNS[piece];
                this.currentY = SPAWN_ROW;
                this.lockDelayTimer = 0;
                this.lockResetCount = 0;
                this.isTouchingGround = false;
                this.hardDropCooldown = 0;
                this.lastGravityTime = 0;
                this.lastActionWasRotation = false;
            }
            
            spawnPiece() {
                const pieceType = this.queue.shift();
                this.queue.push(this.getNextPiece());
                this.resetPieceState(pieceType);
                this.canHold = true;
                this.rotationCooldown = 0;

                this.spawnGrace = true;
                this.spawnGraceUsed = false;

                // Consume buffered rotation immediately on spawn (fixes post-hold rotation delay)
                const rotatedFromBuffer = this.consumeRotationBuffer();

                // Apply IRS only if we didn't just rotate from a buffered tap
                if (!rotatedFromBuffer) {
                    this.applyInitialRotation();
                }

                return true;
            }
            
            applyInitialRotation() {
                if (!this.currentPiece) return;
                
                const input = InputManager.getInstance();
                const heldKeys = input.getHeldKeys();
                const bindings = input.getKeyBindings();
                
                if (heldKeys[bindings.rotate180]) {
                    this.rotate('180');
                } else if (heldKeys[bindings.rotateCW]) {
                    this.rotate('cw');
                } else if (heldKeys[bindings.rotateCCW]) {
                    this.rotate('ccw');
                }
            }
            
            bufferRotation(direction) {
                this.rotateBuffer = { dir: direction, time: performance.now() };
            }
            
            consumeRotationBuffer() {
                if (!this.rotateBuffer) return false;

                const age = performance.now() - this.rotateBuffer.time;
                if (age > ROTATION_BUFFER_MS) {
                    this.rotateBuffer = null;
                    return false;
                }

                const rotated = this.rotate(this.rotateBuffer.dir);
                if (rotated) {
                    this.rotateBuffer = null;
                    return true;
                }
                return false;
            }
            
            isValidPosition(x, y, rotation) {
                if (!this.currentPiece) return false;
                
                const pieceMatrix = this.getRotatedMatrix(this.currentPiece, rotation);
                
                for (let row = 0; row < pieceMatrix.length; row++) {
                    for (let col = 0; col < pieceMatrix[row].length; col++) {
                        if (pieceMatrix[row][col]) {
                            const boardX = x + col;
                            const boardY = y + row;
                            
                            if (boardX < 0 || boardX >= COLS || boardY >= ROWS) {
                                return false;
                            }
                            
                            if (boardY >= 0 && this.grid[boardY][boardX] !== null) {
                                return false;
                            }
                        }
                    }
                }
                
                return true;
            }
            
            getRotatedMatrix(piece, rotation) {
                let matrix = PIECES[piece];
                
                if (rotation === 0) return matrix;
                
                let rotated = matrix;
                for (let i = 0; i < rotation; i++) {
                    rotated = this.rotateMatrix(rotated);
                }
                
                return rotated;
            }
            
            rotateMatrix(matrix) {
                const N = matrix.length;
                const rotated = Array(N).fill().map(() => Array(N).fill(0));
                
                for (let i = 0; i < N; i++) {
                    for (let j = 0; j < N; j++) {
                        rotated[j][N-1-i] = matrix[i][j];
                    }
                }
                
                return rotated;
            }
            
            calculateGhostPosition() {
                let ghostY = this.currentY;
                while (this.isValidPosition(this.currentX, ghostY + 1, this.currentRotation)) {
                    ghostY++;
                }
                this.ghostY = ghostY;
                return ghostY;
            }
            
            move(dx) {
                if (this.gameOver || !this.currentPiece) return false;
                
                if (this.dcdTimer > 0) return false;
                
                const newX = this.currentX + dx;
                if (this.isValidPosition(newX, this.currentY, this.currentRotation)) {
                    this.currentX = newX;
                    this.dcdTimer = GameSettings.getInstance().dcd;
                    return true;
                }
                return false;
            }
            
            rotate(direction) {
                if (!this.currentPiece) return false;
                
                const lockDelayExpired = this.isTouchingGround &&
                    (this.lockDelayTimer >= this.lockDelay || this.lockResetCount >= this.maxLockResets);
                
                if ((!this.spawnGrace || this.spawnGraceUsed) && lockDelayExpired) {
                    return false;
                }
                
                const oldRotation = this.currentRotation;
                let newRotation;
                
                if (direction === 'cw') {
                    newRotation = (oldRotation + 1) % 4;
                } else if (direction === 'ccw') {
                    newRotation = (oldRotation + 3) % 4;
                } else {
                    newRotation = (oldRotation + 2) % 4;
                }
                
                const kickTable = this.currentPiece === 'I' ? KICK_TABLE.I :
                                  this.currentPiece === 'O' ? KICK_TABLE.O : KICK_TABLE.JLSTZ;
                const kickKey = `${ROTATION_STATES[oldRotation]}->${ROTATION_STATES[newRotation]}`;
                const kicks = kickTable[kickKey] || [[0, 0]];
                
                for (const [dx, dy] of kicks) {
                    if (this.isValidPosition(this.currentX + dx, this.currentY - dy, newRotation)) {
                        this.currentX += dx;
                        this.currentY -= dy;
                        this.currentRotation = newRotation;
                        this.lastActionWasRotation = true;
                        if (this.spawnGrace) {
                            this.spawnGraceUsed = true;
                        }
                        
                        if (this.isTouchingGround && this.lockResetCount < this.maxLockResets) {
                            this.lockDelayTimer = 0;
                            this.lockResetCount++;
                        }
                        return true;
                    }
                }
                return false;
            }
            
            drop() {
                if (this.gameOver || !this.currentPiece) return false;
                
                const newY = this.currentY + 1;
                if (this.isValidPosition(this.currentX, newY, this.currentRotation)) {
                    this.currentY = newY;
                    return true;
                } else {
                    this.isTouchingGround = true;
                    return false;
                }
            }
            
            hardDrop() {
                if (this.gameOver || !this.currentPiece || this.hardDropCooldown > 0) return false;
                
                let dropDistance = 0;
                while (this.isValidPosition(this.currentX, this.currentY + 1, this.currentRotation)) {
                    this.currentY++;
                    dropDistance++;
                }
                
                this.score += dropDistance * 2;
                this.lockPiece();
                this.hardDropCooldown = this.hardDropCooldownFrames;
                return true;
            }
            
            setSoftDropActive(active) {
                this.softDropActive = active;
            }
            
            holdCurrentPiece() {
                if (!this.canHold || !this.currentPiece) return false;

                if (this.holdPiece === null) {
                    this.holdPiece = this.currentPiece;
                    this.spawnPiece();
                } else {
                    const temp = this.holdPiece;
                    this.holdPiece = this.currentPiece;
                    this.resetPieceState(temp);

                    this.spawnGrace = true;
                    this.spawnGraceUsed = false;

                    // Consume buffered rotation immediately on hold-swap
                    const rotatedFromBuffer = this.consumeRotationBuffer();

                    // Apply IRS only if we didn't just rotate from a buffered tap
                    if (!rotatedFromBuffer) {
                        this.applyInitialRotation();
                    }
                }

                InputManager.getInstance().resetOnSpawn();
                this.canHold = false;
                return true;
            }
            
            lockPiece() {
                const pieceMatrix = this.getRotatedMatrix(this.currentPiece, this.currentRotation);
                
                for (let row = 0; row < pieceMatrix.length; row++) {
                    for (let col = 0; col < pieceMatrix[row].length; col++) {
                        if (pieceMatrix[row][col]) {
                            const boardX = this.currentX + col;
                            const boardY = this.currentY + row;
                            
                            if (boardY < 0) {
                                this.gameOver = true;
                                return;
                            }
                            
                            this.grid[boardY][boardX] = this.currentPiece;
                        }
                    }
                }
                
                this.piecesPlaced++;
                
                const clearResult = this.clearLines();
                this.updateScore(clearResult);
                
                this.lockDelayTimer = 0;
                this.lockResetCount = 0;
                this.spawnGrace = false;
                this.spawnGraceUsed = false;
                
                this.currentPiece = null;
                
                return clearResult;
            }
            
            clearLines() {
                let linesCleared = 0;
                const clearedRows = [];
                
                for (let row = ROWS - 1; row >= 0; row--) {
                    if (this.grid[row].every(cell => cell !== null)) {
                        clearedRows.push(row);
                        linesCleared++;
                    }
                }
                
                for (const row of clearedRows) {
                    this.grid.splice(row, 1);
                    this.grid.unshift(Array(COLS).fill(null));
                }
                
                if (linesCleared > 0) {
                    this.lines += linesCleared;
                    this.level = Math.floor(this.lines / 10) + 1;
                    GameSettings.getInstance().level = this.level;
                }
                
                const perfectClear = this.grid.every(row => row.every(cell => cell === null));
                
                return { linesCleared, perfectClear };
            }
            
            updateScore(clearResult) {
                const { linesCleared, perfectClear } = clearResult;
                
                if (linesCleared === 0) {
                    this.comboCounter = -1;
                    return;
                }
                
                this.comboCounter++;
                
                let scoreGain = 0;
                let attackLines = 0;
                
                // Basic line clear scoring
                if (linesCleared === 1) {
                    scoreGain = SCORE_TABLE.single;
                    attackLines = ATTACK_TABLE.single;
                } else if (linesCleared === 2) {
                    scoreGain = SCORE_TABLE.double;
                    attackLines = ATTACK_TABLE.double;
                } else if (linesCleared === 3) {
                    scoreGain = SCORE_TABLE.triple;
                    attackLines = ATTACK_TABLE.triple;
                } else if (linesCleared === 4) {
                    scoreGain = SCORE_TABLE.tetris;
                    attackLines = ATTACK_TABLE.tetris;
                    this.lastClearWasB2B = true;
                }
                
                // Combo bonus
                if (this.comboCounter > 0) {
                    scoreGain += this.comboCounter * 50;
                    attackLines += Math.floor(this.comboCounter / 2);
                }
                
                // Perfect clear bonus
                if (perfectClear) {
                    scoreGain += SCORE_TABLE.perfect_clear;
                    attackLines += ATTACK_TABLE.perfect_clear;
                }
                
                // Apply level multiplier
                scoreGain *= this.level;
                
                this.score += scoreGain;
                
                // Send attack to opponent in multiplayer
                if (attackLines > 0 && NetworkManager.getInstance().isConnected()) {
                    NetworkManager.getInstance().sendAttack(attackLines);
                    this.attacksSent += attackLines;
                }
            }
            
            addGarbage(lines) {
                this.pendingGarbage.push(lines);
            }
            
            applyGarbage() {
                if (this.pendingGarbage.length === 0) return;
                
                const lines = this.pendingGarbage.shift();
                for (let i = 0; i < lines; i++) {
                    this.grid.shift();
                    const garbageRow = Array(COLS).fill('garbage');
                    const hole = Math.floor(Math.random() * COLS);
                    garbageRow[hole] = null;
                    this.grid.push(garbageRow);
                }
            }
            
            update(deltaTime) {
                if (!this.currentPiece) return true;
                
                if (this.spawnGrace) {
                    // Allow exactly one rotation window
                    this.spawnGraceUsed = false;
                }

                this.consumeRotationBuffer();
                
                if (this.hardDropCooldown > 0) this.hardDropCooldown--;
                if (this.dcdTimer > 0) this.dcdTimer -= deltaTime;
                
                const wasTouching = this.isTouchingGround;
                this.isTouchingGround = !this.isValidPosition(this.currentX, this.currentY + 1, this.currentRotation);
                
                if (this.isTouchingGround && !wasTouching) {
                    this.lockDelayTimer = 0;
                }
                
                if (this.isTouchingGround) {
                    this.lockDelayTimer += deltaTime;
                    
                    const lockDelayExpired = this.lockDelayTimer >= this.lockDelay || 
                                           this.lockResetCount >= this.maxLockResets;
                    
                    if (lockDelayExpired) {
                        this.lockPiece();
                        this.spawnPiece();
                        InputManager.getInstance().resetOnSpawn();
                        this.applyGarbage();
                        return true;
                    }
                } else {
                    this.lockDelayTimer = 0;
                    this.lockResetCount = 0;
                }
                
                // Gravity
                this.gravityTimer += deltaTime;
                const gravity = GameSettings.getInstance().gravity;
                const effectiveGravity = this.softDropActive ? gravity / GameSettings.getInstance().softDropMultiplier : gravity;
                
                if (this.gravityTimer >= effectiveGravity) {
                    this.gravityTimer = 0;
                    this.drop();
                }
                
                this.calculateGhostPosition();
                return true;
            }
            
            getStateForNetwork() {
                return {
                    grid: this.grid,
                    currentPiece: this.currentPiece,
                    currentX: this.currentX,
                    currentY: this.currentY,
                    currentRotation: this.currentRotation,
                    ghostY: this.ghostY,
                    holdPiece: this.holdPiece,
                    queue: this.queue.slice(0, 5),
                    score: this.score,
                    lines: this.lines,
                    level: this.level,
                    gameOver: this.gameOver
                };
            }
            
            setStateFromNetwork(state) {
                this.opponentState = state;
            }
            
            render() {
                this.calculateGhostPosition();
                this.renderer.render(this);
            }
        }
        
        // =======================================
        // Renderer
        // =======================================
        class TetrisRenderer {
            constructor(canvas, holdCanvas, queueCanvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.holdCanvas = holdCanvas;
                this.holdCtx = holdCanvas.getContext('2d');
                this.queueCanvas = queueCanvas;
                this.queueCtx = queueCanvas.getContext('2d');
                
                this.canvas.width = COLS * BLOCK_SIZE;
                this.canvas.height = ROWS * BLOCK_SIZE;
                
                this.holdCanvas.width = 4 * PREVIEW_BLOCK_SIZE;
                this.holdCanvas.height = 4 * PREVIEW_BLOCK_SIZE;
                
                this.queueCanvas.width = 4 * PREVIEW_BLOCK_SIZE;
                this.queueCanvas.height = 20 * PREVIEW_BLOCK_SIZE;
            }
            
            render(gameState) {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw background grid
                this.drawGrid();
                
                // Draw locked pieces
                this.drawLockedPieces(gameState.grid);
                
                // Draw ghost piece
                if (gameState.currentPiece) {
                    this.drawPiece(gameState.currentPiece, gameState.currentX, gameState.ghostY, gameState.currentRotation, true);
                }
                
                // Draw current piece
                if (gameState.currentPiece) {
                    this.drawPiece(gameState.currentPiece, gameState.currentX, gameState.currentY, gameState.currentRotation);
                }
                
                // Draw hold piece
                this.drawHold(gameState.holdPiece);
                
                // Draw queue
                this.drawQueue(gameState.queue);
                
                // Update UI stats
                this.updateStats(gameState);
            }
            
            drawGrid() {
                this.ctx.strokeStyle = COLORS.grid;
                this.ctx.lineWidth = 1;
                
                for (let x = 0; x <= COLS; x++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x * BLOCK_SIZE, 0);
                    this.ctx.lineTo(x * BLOCK_SIZE, this.canvas.height);
                    this.ctx.stroke();
                }
                
                for (let y = 0; y <= ROWS; y++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y * BLOCK_SIZE);
                    this.ctx.lineTo(this.canvas.width, y * BLOCK_SIZE);
                    this.ctx.stroke();
                }
            }
            
            drawLockedPieces(grid) {
                for (let row = 0; row < ROWS; row++) {
                    for (let col = 0; col < COLS; col++) {
                        if (grid[row][col]) {
                            this.drawBlock(col, row, COLORS[grid[row][col]]);
                        }
                    }
                }
            }
            
            drawPiece(piece, x, y, rotation, isGhost = false) {
                const matrix = this.getRotatedMatrix(piece, rotation);
                const color = isGhost ? COLORS.ghost : COLORS[piece];
                
                for (let row = 0; row < matrix.length; row++) {
                    for (let col = 0; col < matrix[row].length; col++) {
                        if (matrix[row][col]) {
                            const drawX = x + col;
                            const drawY = y + row;
                            
                            if (drawY >= 0) {
                                this.drawBlock(drawX, drawY, color, isGhost);
                            }
                        }
                    }
                }
            }
            
            drawBlock(x, y, color, isGhost = false) {
                this.ctx.fillStyle = color;
                this.ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                
                if (!isGhost) {
                    // Add 3D effect
                    this.ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                    this.ctx.lineWidth = 2;
                    this.ctx.strokeRect(x * BLOCK_SIZE + 1, y * BLOCK_SIZE + 1, BLOCK_SIZE - 2, BLOCK_SIZE - 2);
                    
                    this.ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.moveTo(x * BLOCK_SIZE + BLOCK_SIZE - 1, y * BLOCK_SIZE + 1);
                    this.ctx.lineTo(x * BLOCK_SIZE + BLOCK_SIZE - 1, y * BLOCK_SIZE + BLOCK_SIZE - 1);
                    this.ctx.lineTo(x * BLOCK_SIZE + 1, y * BLOCK_SIZE + BLOCK_SIZE - 1);
                    this.ctx.stroke();
                }
            }
            
            drawHold(holdPiece) {
                this.holdCtx.clearRect(0, 0, this.holdCanvas.width, this.holdCanvas.height);
                
                if (!holdPiece) return;
                
                const matrix = PIECES[holdPiece];
                const color = COLORS[holdPiece];
                
                const offsetX = (4 - matrix[0].length) / 2;
                const offsetY = (4 - matrix.length) / 2;
                
                for (let row = 0; row < matrix.length; row++) {
                    for (let col = 0; col < matrix[row].length; col++) {
                        if (matrix[row][col]) {
                            this.holdCtx.fillStyle = color;
                            this.holdCtx.fillRect(
                                (col + offsetX) * PREVIEW_BLOCK_SIZE,
                                (row + offsetY) * PREVIEW_BLOCK_SIZE,
                                PREVIEW_BLOCK_SIZE,
                                PREVIEW_BLOCK_SIZE
                            );
                        }
                    }
                }
            }
            
            drawQueue(queue) {
                this.queueCtx.clearRect(0, 0, this.queueCanvas.width, this.queueCanvas.height);
                
                for (let i = 0; i < 5; i++) {
                    const piece = queue[i];
                    if (!piece) continue;
                    
                    const matrix = PIECES[piece];
                    const color = COLORS[piece];
                    
                    const offsetX = (4 - matrix[0].length) / 2;
                    const offsetY = i * 4 + (4 - matrix.length) / 2;
                    
                    for (let row = 0; row < matrix.length; row++) {
                        for (let col = 0; col < matrix[row].length; col++) {
                            if (matrix[row][col]) {
                                this.queueCtx.fillStyle = color;
                                this.queueCtx.fillRect(
                                    (col + offsetX) * PREVIEW_BLOCK_SIZE,
                                    (row + offsetY) * PREVIEW_BLOCK_SIZE,
                                    PREVIEW_BLOCK_SIZE,
                                    PREVIEW_BLOCK_SIZE
                                );
                            }
                        }
                    }
                }
            }
            
            updateStats(gameState) {
                if (gameState.isPlayerOne) {
                    document.getElementById('scoreValue').textContent = gameState.score;
                    document.getElementById('linesValue').textContent = gameState.lines;
                    document.getElementById('levelValue').textContent = gameState.level;
                }
            }
            
            getRotatedMatrix(piece, rotation) {
                let matrix = PIECES[piece];
                
                if (rotation === 0) return matrix;
                
                let rotated = matrix;
                for (let i = 0; i < rotation; i++) {
                    rotated = this.rotateMatrix(rotated);
                }
                
                return rotated;
            }
            
            rotateMatrix(matrix) {
                const N = matrix.length;
                const rotated = Array(N).fill().map(() => Array(N).fill(0));
                
                for (let i = 0; i < N; i++) {
                    for (let j = 0; j < N; j++) {
                        rotated[j][N-1-i] = matrix[i][j];
                    }
                }
                
                return rotated;
            }
        }
        
        // =======================================
        // Main game controller
        // =======================================
        class GameController {
            constructor() {
                this.gameState1 = null;
                this.gameState2 = null;
                this.gameRunning = false;
                this.lastTime = 0;
                this.lastStateSendTime = 0;
                this.animationFrameId = null;
                
                this.();
                this.setupInput();
            }
            
            setupUI() {
  const net = NetworkManager.getInstance();
  net.initialize(this.handleNetworkMessage.bind(this));

  // Copy room code
  window.copyPeerId = () => {
    const text = (document.getElementById("peerIdDisplay")?.textContent || "").trim();
    if (!text || text === "Connecting...") return;
    navigator.clipboard.writeText(text).then(() => ChatManager.addMessage("Room code copied!"));
  };

  const createBtn = document.getElementById("createGameBtn");
  const joinBtn = document.getElementById("joinGameBtn");
  const restartBtn = document.getElementById("restartBtn");
  const joinInput = document.getElementById("opponentPeerId");
  const gameArea = document.getElementById("gameArea");

  // ---- settings hookup (YOUR real IDs) ----
  const applySettings = () => GameSettings.getInstance().updateFromUI();
  ["das", "arr", "dcd", "sdf", "preventMissdrop"].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.addEventListener("change", applySettings);
  });
  applySettings(); // initial sync from UI

  // ---- create / join ----
  createBtn.addEventListener("click", async () => {
    createBtn.disabled = true;
    joinBtn.disabled = true;

    await net.host(); // sets status + shows code

    restartBtn.classList.remove("hidden");
  });

  joinBtn.addEventListener("click", () => {
    const code = joinInput.value.trim().toUpperCase();
    if (!code) {
      document.getElementById("gameStatus").textContent = "Enter a room code first.";
      return;
    }

    createBtn.disabled = true;
    joinBtn.disabled = true;
    restartBtn.classList.remove("hidden");

    document.getElementById("myPeerId").classList.remove("hidden");
    document.getElementById("peerIdDisplay").textContent = code;

    net.join(code);
  });

  restartBtn.addEventListener("click", () => location.reload());

  // Show game UI once game starts
  this.onGameStartUI = () => {
    if (gameArea) gameArea.classList.remove("hidden");
  };

  // ---- key rebinding (focus input then press key) ----
  const keyInputs = {
    keyLeft: "left",
    keyRight: "right",
    keySoftDrop: "softDrop",
    keyHardDrop: "hardDrop",
    keyHold: "hold",
    keyRotateCW: "rotateCW",
    keyRotateCCW: "rotateCCW",
    keyRotate180: "rotate180"
  };

  Object.entries(keyInputs).forEach(([inputId, action]) => {
    const input = document.getElementById(inputId);
    if (!input) return;

    // Make sure readonly inputs can still receive keydown
    input.addEventListener("click", () => input.focus());

    input.addEventListener("keydown", (e) => {
      e.preventDefault();
      InputManager.getInstance().setKeyBinding(action, e.key);
      input.value = e.key;
    });
  });
}

            
            setupInput() {
    const input = InputManager.getInstance();
    input.setupKeyBindings();

    input.onMoveImmediate = (dx) => {
        if (this.gameState1) this.gameState1.move(dx);
    };

    document.addEventListener('keydown', (e) => {
        if (!this.gameRunning || !this.gameState1) return;

        const b = input.getKeyBindings();
        input.handleKeyDown(e.key);

        if (Object.values(b).includes(e.key)) e.preventDefault();

        if (e.key === b.softDrop) {
            this.gameState1.setSoftDropActive(true);
        } else if (e.key === b.hardDrop) {
            this.gameState1.hardDrop();
            this.gameState1.spawnPiece();
            InputManager.getInstance().resetOnSpawn();
        } else if (e.key === b.rotateCW) {
            this.gameState1.bufferRotation('cw');
            this.gameState1.consumeRotationBuffer();
        } else if (e.key === b.rotateCCW) {
            this.gameState1.bufferRotation('ccw');
            this.gameState1.consumeRotationBuffer();
        } else if (e.key === b.rotate180) {
            this.gameState1.bufferRotation('180');
            this.gameState1.consumeRotationBuffer();
        } else if (e.key === b.hold) {
            this.gameState1.holdCurrentPiece();
        }
    });

    document.addEventListener('keyup', (e) => {
        input.handleKeyUp(e.key);

        if (this.gameState1 && e.key === input.getKeyBindings().softDrop) {
            this.gameState1.setSoftDropActive(false);
        }
    });
}
            
            handleNetworkMessage(data) {
  if (!data || !data.type) return;

  if (data.type === "startGame") {
    // Host sends this, join receives it. Host also self-triggers it in NetworkManager.
    if (this.onGameStartUI) this.onGameStartUI();
    this.startGame();
    return;
  }

  if (data.type === "gameState") {
    if (this.gameState2) this.gameState2.setStateFromNetwork(data.state);
    return;
  }

  if (data.type === "attack") {
    if (this.gameState1) this.gameState1.addGarbage(data.lines);
    return;
  }
}

            
           startGame() {
  if (this.gameRunning) return;

  this.gameState1 = new TetrisGameState("gameCanvas1", "holdCanvas1", "queueCanvas1", true);
  this.gameState2 = new TetrisGameState("gameCanvas2", "holdCanvas2", "queueCanvas2", false);

  this.gameRunning = true;
  this.lastTime = performance.now();
  this.lastStateSendTime = 0;

  document.getElementById("gameStatus").textContent = "Game in progress";

  this.gameLoop();
}

            
            gameLoop(currentTime = performance.now()) {
                if (!this.gameRunning) return;
                
                const deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;
                
                // Update input
                InputManager.getInstance().update(deltaTime, (dx) => {
                    if (this.gameState1) this.gameState1.move(dx);
                });
                
                // Update game state
                this.gameState1.update(deltaTime);
                this.gameState1.render();
                
                // Send state to opponent
                this.lastStateSendTime += deltaTime;
                if (NetworkManager.getInstance().isConnected() && this.lastStateSendTime >= STATE_SEND_INTERVAL) {
                    NetworkManager.getInstance().sendGameState(this.gameState1.getStateForNetwork());
                    this.lastStateSendTime = 0;
                }
                
                // Render opponent state if available
                if (this.gameState2 && this.gameState2.opponentState) {
                    this.gameState2.renderer.render(this.gameState2.opponentState);
                }
                
                // Check game over
                if (this.gameState1.gameOver) {
                    this.gameRunning = false;
                    document.getElementById('gameStatus').textContent = 'Game Over';
                    
                    if (NetworkManager.getInstance().isConnected()) {
                        NetworkManager.getInstance().send({ type: 'gameOver' });
                    }
                    return;
                }
                
                this.animationFrameId = requestAnimationFrame(this.gameLoop.bind(this));
            }
        }
        
        // ========================================================================
        // Initialize
        // ========================================================================
        
        new GameController();
</script>

</body>
</html>
