<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris Multiplayer - GitHub Pages</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Orbitron:wght@400;700;900&display=swap');
        
        :root {
            --bg-dark: #0a0e27;
            --bg-grid: #151b3d;
            --border-glow: #00ffff;
            --text-primary: #ffffff;
            --text-secondary: #8b9dc3;
            --accent-cyan: #00ffff;
            --accent-pink: #ff00ff;
            --accent-yellow: #ffff00;
            --shadow-glow: 0 0 20px rgba(0, 255, 255, 0.5);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Orbitron', monospace;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f4d 100%);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0, 255, 255, 0.03) 2px, rgba(0, 255, 255, 0.03) 4px),
                repeating-linear-gradient(90deg, transparent, transparent 2px, rgba(255, 0, 255, 0.03) 2px, rgba(255, 0, 255, 0.03) 4px);
            pointer-events: none;
            animation: scanlines 8s linear infinite;
        }
        
        @keyframes scanlines {
            0% { transform: translateY(0); }
            100% { transform: translateY(4px); }
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 1;
        }
        
        h1 {
            font-family: 'Press Start 2P', cursive;
            text-align: center;
            font-size: 2rem;
            margin-bottom: 30px;
            text-transform: uppercase;
            background: linear-gradient(45deg, var(--accent-cyan), var(--accent-pink), var(--accent-yellow));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 10px rgba(0, 255, 255, 0.5));
            animation: glow-pulse 2s ease-in-out infinite;
        }
        
        @keyframes glow-pulse {
            0%, 100% { filter: drop-shadow(0 0 10px rgba(0, 255, 255, 0.5)); }
            50% { filter: drop-shadow(0 0 20px rgba(255, 0, 255, 0.8)); }
        }
        
        .controls-panel {
            background: rgba(21, 27, 61, 0.8);
            border: 2px solid var(--border-glow);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: var(--shadow-glow);
        }
        
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .control-item {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .control-item label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            text-transform: uppercase;
        }
        
        .control-item input, .control-item select {
            background: rgba(10, 14, 39, 0.9);
            border: 1px solid var(--accent-cyan);
            color: var(--text-primary);
            padding: 8px;
            border-radius: 5px;
            font-family: 'Orbitron', monospace;
            font-size: 0.9rem;
        }
        
        .control-item input:focus, .control-item select:focus {
            outline: none;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        button {
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-pink));
            border: none;
            color: var(--bg-dark);
            padding: 12px 24px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.7rem;
            border-radius: 5px;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 255, 255, 0.3);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 0, 255, 0.5);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .game-area {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin-top: 30px;
            flex-wrap: wrap;
        }
        
        .player-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        
        .player-header {
            font-family: 'Press Start 2P', cursive;
            font-size: 1rem;
            color: var(--accent-cyan);
            text-shadow: 0 0 10px var(--accent-cyan);
        }
        
        .game-wrapper {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }
        
        .side-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .info-box {
            background: rgba(21, 27, 61, 0.9);
            border: 2px solid var(--accent-cyan);
            border-radius: 8px;
            padding: 15px;
            min-width: 150px;
            box-shadow: var(--shadow-glow);
        }
        
        .info-box h3 {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.6rem;
            margin-bottom: 10px;
            color: var(--accent-yellow);
            text-align: center;
        }
        
        .stat {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 0.9rem;
        }
        
        .stat-label {
            color: var(--text-secondary);
            font-size: 0.75rem;
        }
        
        .stat-value {
            color: var(--accent-cyan);
            font-weight: bold;
        }
        
        .canvas-container {
            position: relative;
            border: 3px solid var(--border-glow);
            border-radius: 5px;
            box-shadow: 
                var(--shadow-glow),
                inset 0 0 20px rgba(0, 255, 255, 0.1);
            background: rgba(10, 14, 39, 0.95);
        }
        
        canvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        .mini-canvas-container {
            background: rgba(10, 14, 39, 0.9);
            border: 2px solid var(--accent-pink);
            border-radius: 5px;
            padding: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100px;
        }
        
        .chat-container {
            background: rgba(21, 27, 61, 0.9);
            border: 2px solid var(--border-glow);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            box-shadow: var(--shadow-glow);
        }
        
        .chat-messages {
            height: 150px;
            overflow-y: auto;
            background: rgba(10, 14, 39, 0.8);
            border: 1px solid var(--accent-cyan);
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 10px;
            font-size: 0.85rem;
        }
        
        .chat-message {
            margin: 5px 0;
            padding: 5px;
            border-left: 2px solid var(--accent-pink);
            padding-left: 8px;
        }
        
        .chat-input-container {
            display: flex;
            gap: 10px;
        }
        
        .chat-input {
            flex: 1;
            background: rgba(10, 14, 39, 0.9);
            border: 1px solid var(--accent-cyan);
            color: var(--text-primary);
            padding: 10px;
            border-radius: 5px;
            font-family: 'Orbitron', monospace;
        }
        
        .connection-panel {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .connection-panel input {
            background: rgba(10, 14, 39, 0.9);
            border: 1px solid var(--accent-cyan);
            color: var(--text-primary);
            padding: 10px;
            border-radius: 5px;
            font-family: 'Orbitron', monospace;
            width: 300px;
        }
        
        #gameStatus {
            text-align: center;
            margin-top: 20px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
            color: var(--accent-yellow);
            text-shadow: 0 0 10px var(--accent-yellow);
        }
        
        #myPeerId {
            background: rgba(21, 27, 61, 0.9);
            border: 2px solid var(--accent-cyan);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 20px;
            box-shadow: var(--shadow-glow);
        }
        
        #myPeerId .peer-id-label {
            font-size: 0.7rem;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }
        
        #myPeerId .peer-id-value {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.9rem;
            color: var(--accent-cyan);
            word-break: break-all;
            user-select: all;
            cursor: pointer;
            padding: 10px;
            background: rgba(10, 14, 39, 0.8);
            border-radius: 5px;
            border: 1px solid var(--accent-pink);
        }
        
        .hidden {
            display: none !important;
        }

        .copy-btn {
            margin-top: 10px;
            font-size: 0.6rem;
            padding: 8px 16px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>â¬› Tetris Online Battle â¬›</h1>
        
        <div class="controls-panel">
            <h2 style="font-family: 'Press Start 2P', cursive; font-size: 1rem; margin-bottom: 15px; text-align: center;">Game Settings</h2>
            
            <div class="controls-grid">
                <div class="control-item">
                    <label>Move Left</label>
                    <input type="text" id="keyLeft" value="ArrowLeft" readonly>
                </div>
                <div class="control-item">
                    <label>Move Right</label>
                    <input type="text" id="keyRight" value="ArrowRight" readonly>
                </div>
                <div class="control-item">
                    <label>Soft Drop</label>
                    <input type="text" id="keySoftDrop" value="ArrowDown" readonly>
                </div>
                <div class="control-item">
                    <label>Hard Drop</label>
                    <input type="text" id="keyHardDrop" value=" " readonly>
                </div>
                <div class="control-item">
                    <label>Rotate CW</label>
                    <input type="text" id="keyRotateCW" value="ArrowUp" readonly>
                </div>
                <div class="control-item">
                    <label>Rotate CCW</label>
                    <input type="text" id="keyRotateCCW" value="z" readonly>
                </div>
                <div class="control-item">
                    <label>Rotate 180</label>
                    <input type="text" id="keyRotate180" value="x" readonly>
                </div>
                <div class="control-item">
                    <label>Hold Piece</label>
                    <input type="text" id="keyHold" value="c" readonly>
                </div>
                <div class="control-item">
                    <label>ARR (ms)</label>
                    <input type="number" id="arr" value="0" min="0" max="200">
                </div>
                <div class="control-item">
                    <label>DAS (ms)</label>
                    <input type="number" id="das" value="167" min="0" max="500">
                </div>
                <div class="control-item">
                    <label>DCD (ms)</label>
                    <input type="number" id="dcd" value="0" min="0" max="100">
                </div>
                <div class="control-item">
                    <label>SDF (multiplier)</label>
                    <select id="sdf">
                        <option value="1">1x</option>
                        <option value="2">2x</option>
                        <option value="6" selected>6x</option>
                        <option value="10">10x</option>
                        <option value="20">20x</option>
                        <option value="inf">Infinite</option>
                    </select>
                </div>
                <div class="control-item">
                    <label>Prevent Missdrop</label>
                    <select id="preventMissdrop">
                        <option value="true" selected>On</option>
                        <option value="false">Off</option>
                    </select>
                </div>
            </div>
            
            <div style="text-align: center; margin-top: 15px; color: var(--text-secondary); font-size: 0.75rem;">
                Click on any key binding to change it
            </div>
        </div>
        
        <div id="myPeerId" class="hidden">
            <div class="peer-id-label">YOUR PEER ID (share this with your opponent):</div>
            <div class="peer-id-value" id="peerIdDisplay" onclick="copyPeerId()">Connecting...</div>
            <button class="copy-btn" onclick="copyPeerId()">ðŸ“‹ Copy ID</button>
        </div>
        
        <div class="connection-panel">
            <button id="createGameBtn">Create Game</button>
            <input type="text" id="opponentPeerId" placeholder="Enter opponent's Peer ID to join">
            <button id="joinGameBtn">Join Game</button>
            <button id="restartBtn" class="hidden">Restart Game</button>
        </div>
        
        <div id="gameStatus">Click "Create Game" to host or enter a Peer ID to join</div>
        
        <div class="game-area hidden" id="gameArea">
            <div class="player-container">
                <div class="player-header">ðŸŽ® YOU</div>
                <div class="game-wrapper">
                    <div class="side-panel">
                        <div class="info-box">
                            <h3>HOLD</h3>
                            <div class="mini-canvas-container">
                                <canvas id="holdCanvas1" width="80" height="80"></canvas>
                            </div>
                        </div>
                        <div class="info-box">
                            <h3>STATS</h3>
                            <div class="stat">
                                <span class="stat-label">PPS:</span>
                                <span class="stat-value" id="pps1">0.00</span>
                            </div>
                            <div class="stat">
                                <span class="stat-label">APM:</span>
                                <span class="stat-value" id="apm1">0.00</span>
                            </div>
                            <div class="stat">
                                <span class="stat-label">B2B:</span>
                                <span class="stat-value" id="b2b1">0</span>
                            </div>
                            <div class="stat">
                                <span class="stat-label">Combo:</span>
                                <span class="stat-value" id="combo1">0</span>
                            </div>
                        </div>
                    </div>
                    <div class="canvas-container">
                        <canvas id="gameCanvas1" width="320" height="640"></canvas>
                    </div>
                    <div class="side-panel">
                        <div class="info-box">
                            <h3>NEXT</h3>
                            <div class="mini-canvas-container">
                                <canvas id="queueCanvas1" width="80" height="480"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="player-container">
                <div class="player-header">ðŸŽ® OPPONENT</div>
                <div class="game-wrapper">
                    <div class="side-panel">
                        <div class="info-box">
                            <h3>HOLD</h3>
                            <div class="mini-canvas-container">
                                <canvas id="holdCanvas2" width="80" height="80"></canvas>
                            </div>
                        </div>
                        <div class="info-box">
                            <h3>STATS</h3>
                            <div class="stat">
                                <span class="stat-label">PPS:</span>
                                <span class="stat-value" id="pps2">0.00</span>
                            </div>
                            <div class="stat">
                                <span class="stat-label">APM:</span>
                                <span class="stat-value" id="apm2">0.00</span>
                            </div>
                            <div class="stat">
                                <span class="stat-label">B2B:</span>
                                <span class="stat-value" id="b2b2">0</span>
                            </div>
                            <div class="stat">
                                <span class="stat-label">Combo:</span>
                                <span class="stat-value" id="combo2">0</span>
                            </div>
                        </div>
                    </div>
                    <div class="canvas-container">
                        <canvas id="gameCanvas2" width="320" height="640"></canvas>
                    </div>
                    <div class="side-panel">
                        <div class="info-box">
                            <h3>NEXT</h3>
                            <div class="mini-canvas-container">
                                <canvas id="queueCanvas2" width="80" height="480"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="chat-container">
            <h3 style="font-family: 'Press Start 2P', cursive; font-size: 0.8rem; margin-bottom: 10px; text-align: center; color: var(--accent-yellow);">ðŸ’¬ CHAT</h3>
            <div class="chat-messages" id="chatMessages"></div>
            <div class="chat-input-container">
                <input type="text" class="chat-input" id="chatInput" placeholder="Type a message...">
                <button id="sendChatBtn">Send</button>
            </div>
        </div>
    </div>
    
    <script>
/* Rewritten game script for game_4.html
   - Keeps the existing UI (IDs/classes unchanged)
   - Fixes IRS/IHS with an input buffer (ms-based)
   - Improves rotation responsiveness (SRS kicks + buffered inputs)
   - Implements DAS/ARR and DCD basics
   - Shorter, clearer PeerJS connection logic
   Paste this entire <script> block in place of the current script tag.
*/

/* -------------------------
   Constants & Utilities
   ------------------------- */
const COLS = 10, ROWS = 20;
const BLOCK_SIZE = 32;
const PREVIEW_BLOCK_SIZE = 16;
const STATE_SEND_INTERVAL = 50; // ms for sending state to opponent

function nowMs(){ return performance.now(); }
function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
function deepClone(o){ return JSON.parse(JSON.stringify(o)); }

/* -------------------------
   Seeded RNG (LCG)
   ------------------------- */
class SeededRandom {
  constructor(seed=Date.now()|0){ this.seed = seed >>> 0; }
  next(){
    this.seed = (this.seed * 1664525 + 1013904223) >>> 0;
    return this.seed / 0x100000000;
  }
  nextInt(max){ return Math.floor(this.next() * max); }
}

/* -------------------------
   SRS Kick Tables & Shapes
   (kept compatible with original file)
   ------------------------- */
const KICK_TABLE = {
  JLSTZ: {
    "0->R":[[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],
    "R->0":[[0,0],[1,0],[1,-1],[0,2],[1,2]],
    "R->2":[[0,0],[1,0],[1,-1],[0,2],[1,2]],
    "2->R":[[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],
    "2->L":[[0,0],[1,0],[1,1],[0,-2],[1,-2]],
    "L->2":[[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],
    "L->0":[[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],
    "0->L":[[0,0],[1,0],[1,1],[0,-2],[1,-2]]
  },
  I: {
    "0->R":[[0,0],[-2,0],[1,0],[-2,-1],[1,2]],
    "R->0":[[0,0],[2,0],[-1,0],[2,1],[-1,-2]],
    "R->2":[[0,0],[-1,0],[2,0],[-1,2],[2,-1]],
    "2->R":[[0,0],[1,0],[-2,0],[1,-2],[-2,1]],
    "2->L":[[0,0],[2,0],[-1,0],[2,1],[-1,-2]],
    "L->2":[[0,0],[-2,0],[1,0],[-2,-1],[1,2]],
    "L->0":[[0,0],[1,0],[-2,0],[1,-2],[-2,1]],
    "0->L":[[0,0],[-1,0],[2,0],[-1,2],[2,-1]]
  },
  O: {
    // O has no kicks (identity)
    "0->R":[[0,0]], "R->0":[[0,0]], "R->2":[[0,0]], "2->R":[[0,0]],
    "2->L":[[0,0]], "L->2":[[0,0]], "L->0":[[0,0]], "0->L":[[0,0]]
  }
};

const SHAPES = {
  I: { color:'#00f0f0', shape:[
    [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
    [[0,0,1,0],[0,0,1,0],[0,0,1,0],[0,0,1,0]],
    [[0,0,0,0],[0,0,0,0],[1,1,1,1],[0,0,0,0]],
    [[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]]
  ]},
  O: { color:'#f0f000', shape:[
    [[1,1],[1,1]],[[1,1],[1,1]],[[1,1],[1,1]],[[1,1],[1,1]]
  ]},
  T: { color:'#a000f0', shape:[
    [[0,1,0],[1,1,1],[0,0,0]],
    [[0,1,0],[0,1,1],[0,1,0]],
    [[0,0,0],[1,1,1],[0,1,0]],
    [[0,1,0],[1,1,0],[0,1,0]]
  ]},
  S: { color:'#00f000', shape:[
    [[0,1,1],[1,1,0],[0,0,0]],
    [[0,1,0],[0,1,1],[0,0,1]],
    [[0,0,0],[0,1,1],[1,1,0]],
    [[1,0,0],[1,1,0],[0,1,0]]
  ]},
  Z: { color:'#f00000', shape:[
    [[1,1,0],[0,1,1],[0,0,0]],
    [[0,0,1],[0,1,1],[0,1,0]],
    [[0,0,0],[1,1,0],[0,1,1]],
    [[0,1,0],[1,1,0],[1,0,0]]
  ]},
  J: { color:'#0000f0', shape:[
    [[1,0,0],[1,1,1],[0,0,0]],
    [[0,1,1],[0,1,0],[0,1,0]],
    [[0,0,0],[1,1,1],[0,0,1]],
    [[0,1,0],[0,1,0],[1,1,0]]
  ]},
  L: { color:'#f0a000', shape:[
    [[0,0,1],[1,1,1],[0,0,0]],
    [[0,1,0],[0,1,0],[0,1,1]],
    [[0,0,0],[1,1,1],[1,0,0]],
    [[1,1,0],[0,1,0],[0,1,0]]
  ]}
};

const PIECE_TYPES = Object.keys(SHAPES);

/* -------------------------
   Helper drawing functions
   ------------------------- */
function drawBlock(ctx, x, y, color, alpha=1){
  ctx.globalAlpha = alpha;
  ctx.fillStyle = color;
  ctx.fillRect(x+1, y+1, BLOCK_SIZE-2, BLOCK_SIZE-2);
  ctx.globalAlpha = 1;
}
function clearCanvas(ctx, w, h){
  ctx.clearRect(0,0,w,h);
}

/* -------------------------
   GameState class (single-player logic)
   - Input buffer for IRS/IHS (ms-based)
   - DAS/ARR support
   - SRS rotation with kicks
   ------------------------- */
class GameState {
  constructor(canvasId, holdCanvasId, queueCanvasId, playerId, seed){
    this.canvas = document.getElementById(canvasId);
    this.ctx = this.canvas.getContext('2d');
    this.holdCanvas = document.getElementById(holdCanvasId);
    this.holdCtx = this.holdCanvas.getContext('2d');
    this.queueCanvas = document.getElementById(queueCanvasId);
    this.queueCtx = this.queueCanvas.getContext('2d');
    this.playerId = playerId;
    this.rng = new SeededRandom(seed || (Date.now()|0));
    this.reset();
    // Input buffer for IRS/IHS
    this.inputBuffer = []; // {type:'rotate'|'hold'|'move'|'harddrop', dir?, dx?, time}
    this.inputBufferMaxAge = 250; // ms
    this.spawnCooldownMs = 60; // ms window where inputs are buffered
    this.spawnCooldownTimer = 0;
    // DAS/ARR state
    this.dasDirection = 0; // -1 left, 1 right, 0 none
    this.dasTimer = 0;
    this.arrTimer = 0;
    // other timers
    this.gravityTimer = 0;
    this.lockDelayTimer = 0;
    this.lockDelayMs = 500;
    this.lockResetCount = 0;
    this.maxLockResets = 15;
    this.hardDropCooldownMs = 0;
  }

  reset(){
    this.board = Array.from({length:ROWS}, ()=>Array(COLS).fill(0));
    this.bag = [];
    this.queue = [];
    for(let i=0;i<6;i++) this.queue.push(this.getNextPiece());
    this.currentPiece = null;
    this.currentRotation = 0;
    this.currentX = 3;
    this.currentY = 0;
    this.holdPiece = null;
    this.canHold = true;
    this.piecesPlaced = 0;
    this.attacksSent = 0;
    this.b2bCounter = 0;
    this.comboCounter = -1;
    this.lastClearWasB2B = false;
    this.pendingGarbage = [];
    this.gameStartTime = nowMs();
    this.gravityMs = 800;
    this.spawnPiece();
  }

  getNextPiece(){
    if(this.bag.length===0){
      this.bag = [...PIECE_TYPES];
      // Fisher-Yates shuffle with seeded RNG
      for(let i=this.bag.length-1;i>0;i--){
        const j = this.rng.nextInt(i+1);
        [this.bag[i], this.bag[j]] = [this.bag[j], this.bag[i]];
      }
    }
    return this.bag.pop();
  }

  getSpawnColumn(type){
    const spawnCols = { O:4, T:3, Z:3, I:3, L:3, J:3, S:3 };
    return spawnCols[type] || 3;
  }

  spawnPiece(){
    const piece = this.queue.shift();
    this.queue.push(this.getNextPiece());
    this.currentPiece = piece;
    this.currentRotation = 0;
    this.currentX = this.getSpawnColumn(piece);
    this.currentY = 0;
    this.canHold = true;
    this.lockDelayTimer = 0;
    this.lockResetCount = 0;
    this.isTouchingGround = false;
    // start spawn cooldown (ms)
    this.spawnCooldownTimer = this.spawnCooldownMs;
    // keep inputBuffer (we don't clear it) so IRS/IHS works
  }

  // Input buffer processing when spawn cooldown ends
  processSpawnBuffer(){
    const now = nowMs();
    this.inputBuffer = this.inputBuffer.filter(it => now - it.time <= this.inputBufferMaxAge);
    while(this.inputBuffer.length){
      const it = this.inputBuffer.shift();
      if(it.type === 'rotate'){
        if(this.rotate(it.dir)) return; // rotation consumed
      } else if(it.type === 'hold'){
        if(this.holdCurrentPiece()) return;
      } else if(it.type === 'move'){
        this.move(it.dx);
        // continue processing moves (do not consume rotation buffer)
      } else if(it.type === 'harddrop'){
        if(this.hardDrop()) return;
      }
    }
  }

  // SRS rotation with kicks
  rotate(direction){
    // direction: 'cw' | 'ccw' | '180'
    // If spawn cooldown active, buffer rotation (IRS)
    if(this.spawnCooldownTimer > 0){
      // only queue one rotation (keep latest)
      this.inputBuffer.push({ type:'rotate', dir:direction, time: nowMs() });
      return false;
    }

    const oldR = this.currentRotation;
    let newR;
    if(direction === 'cw') newR = (oldR + 1) % 4;
    else if(direction === 'ccw') newR = (oldR + 3) % 4;
    else newR = (oldR + 2) % 4;

    const rotations = ['0','R','2','L'];
    const key = `${rotations[oldR]}->${rotations[newR]}`;
    const kickSet = (this.currentPiece === 'I') ? KICK_TABLE.I :
                    (this.currentPiece === 'O') ? KICK_TABLE.O : KICK_TABLE.JLSTZ;
    const kicks = kickSet[key] || [[0,0]];

    for(const [dx,dy] of kicks){
      const testX = this.currentX + dx;
      const testY = this.currentY - dy;
      if(this.isValidPosition(testX, testY, newR)){
        this.currentX = testX;
        this.currentY = testY;
        this.currentRotation = newR;
        // lock reset if touching ground
        if(this.isTouchingGround && this.lockResetCount < this.maxLockResets){
          this.lockDelayTimer = 0;
          this.lockResetCount++;
        }
        return true;
      }
    }
    return false;
  }

  isValidPosition(x, y, rotation){
    const shape = SHAPES[this.currentPiece].shape[rotation];
    for(let r=0;r<shape.length;r++){
      for(let c=0;c<shape[r].length;c++){
        if(!shape[r][c]) continue;
        const gx = x + c, gy = y + r;
        if(gx < 0 || gx >= COLS || gy >= ROWS) return false;
        if(gy >= 0 && this.board[gy][gx]) return false;
      }
    }
    return true;
  }

  move(dx){
    // If spawn cooldown active, buffer move (so player can press during spawn)
    if(this.spawnCooldownTimer > 0){
      this.inputBuffer.push({ type:'move', dx:dx, time: nowMs() });
      return false;
    }
    if(this.isValidPosition(this.currentX + dx, this.currentY, this.currentRotation)){
      this.currentX += dx;
      if(this.isTouchingGround && this.lockResetCount < this.maxLockResets){
        this.lockDelayTimer = 0;
        this.lockResetCount++;
      }
      return true;
    }
    return false;
  }

  softDrop(){
    if(this.isValidPosition(this.currentX, this.currentY + 1, this.currentRotation)){
      this.currentY++;
      return true;
    }
    return false;
  }

  hardDrop(){
    // If spawn cooldown active, buffer harddrop
    if(this.spawnCooldownTimer > 0){
      this.inputBuffer.push({ type:'harddrop', time: nowMs() });
      return false;
    }
    while(this.isValidPosition(this.currentX, this.currentY + 1, this.currentRotation)) this.currentY++;
    return this.lockPiece();
  }

  holdCurrentPiece(){
    // IHS: buffer hold if spawn cooldown active
    if(this.spawnCooldownTimer > 0){
      this.inputBuffer.push({ type:'hold', time: nowMs() });
      return false;
    }
    if(!this.canHold) return false;
    if(this.holdPiece === null){
      this.holdPiece = this.currentPiece;
      this.spawnPiece();
    } else {
      const prev = this.holdPiece;
      this.holdPiece = this.currentPiece;
      this.currentPiece = prev;
      this.currentRotation = 0;
      this.currentX = this.getSpawnColumn(this.currentPiece);
      this.currentY = 0;
      // after swapping, start spawn cooldown to allow immediate inputs to be buffered
      this.spawnCooldownTimer = this.spawnCooldownMs;
    }
    this.canHold = false;
    return true;
  }

  lockPiece(){
    const shape = SHAPES[this.currentPiece].shape[this.currentRotation];
    for(let r=0;r<shape.length;r++){
      for(let c=0;c<shape[r].length;c++){
        if(!shape[r][c]) continue;
        const gx = this.currentX + c, gy = this.currentY + r;
        if(gy >= 0 && gy < ROWS && gx >= 0 && gx < COLS){
          this.board[gy][gx] = this.currentPiece;
        } else if(gy < 0){
          // piece locked above top -> game over
          return false;
        }
      }
    }
    this.piecesPlaced++;
    this.lockDelayTimer = 0;
    this.lockResetCount = 0;
    this.isTouchingGround = false;
    this.clearLines(this.currentPiece, this.currentX, this.currentY, this.currentRotation);
    // spawn next piece
    this.spawnPiece();
    return true;
  }

  clearLines(lastPieceType, lastX, lastY, lastRotation){
    const cleared = [];
    for(let r=0;r<ROWS;r++){
      if(this.board[r].every(cell => cell !== 0)) cleared.push(r);
    }
    const lines = cleared.length;
    if(lines > 0){
      // remove rows
      for(let i=cleared.length-1;i>=0;i--) this.board.splice(cleared[i],1);
      for(let i=0;i<lines;i++) this.board.unshift(Array(COLS).fill(0));
      // T-spin detection (simplified)
      const isSpin = (lastPieceType === 'T') && this.checkTSpin(lastX, lastY);
      const isAllClear = this.board.every(row => row.every(cell => cell === 0));
      let attack = this.calculateAttack(lines, isSpin, isAllClear, lastPieceType);
      const isB2BMove = (lines === 4) || isSpin;
      if(isB2BMove){
        if(this.lastClearWasB2B) this.b2bCounter++;
        else this.b2bCounter = 1;
        this.lastClearWasB2B = true;
      } else {
        this.b2bCounter = 0;
        this.lastClearWasB2B = false;
      }
      this.comboCounter = (this.comboCounter >= 0) ? this.comboCounter + 1 : 0;
      if(this.comboCounter >= 4) attack += 1;
      // pending garbage cancellation
      if(this.pendingGarbage.length > 0 && attack > 0){
        let totalPending = this.pendingGarbage.reduce((s,g)=>s+g.lines,0);
        if(attack >= totalPending){
          attack -= totalPending;
          this.pendingGarbage = [];
          addChatMessage(`Canceled ${totalPending} garbage lines!`, 'System');
        } else {
          let remaining = attack;
          this.pendingGarbage = this.pendingGarbage.filter(g=>{
            if(remaining >= g.lines){ remaining -= g.lines; return false; }
            if(remaining > 0){ g.lines -= remaining; remaining = 0; return true; }
            return true;
          });
          addChatMessage(`Canceled ${attack} garbage lines!`, 'System');
          attack = 0;
        }
      }
      this.attacksSent += attack;
      if(attack > 0) this.sendAttack(attack);
    } else {
      this.comboCounter = -1;
      if(this.pendingGarbage.length > 0) this.applyGarbage();
    }
    this.updateStats();
  }

  checkTSpin(x,y){
    // simplified T-spin corner check
    const corners = [
      [x, y],
      [x+2, y],
      [x, y+2],
      [x+2, y+2]
    ];
    let filled = 0;
    for(const [cx,cy] of corners){
      if(cx < 0 || cx >= COLS || cy < 0 || cy >= ROWS || this.board[cy][cx]) filled++;
    }
    return filled >= 3;
  }

  calculateAttack(lines, isSpin, isAllClear, pieceType){
    let attack = 0;
    if(isAllClear){
      attack = (lines === 4) ? 10 : 8;
    } else if(pieceType === 'T' && isSpin){
      if(lines === 1) attack = 2;
      else if(lines === 2) attack = 4;
      else if(lines === 3) attack = 6;
    } else if(isSpin){
      attack = lines;
    } else {
      if(lines === 1) attack = 0;
      else if(lines === 2) attack = 1;
      else if(lines === 3) attack = 2;
      else if(lines === 4) attack = 4;
    }
    return attack;
  }

  sendAttack(lines){
    if(conn && conn.open && lines > 0){
      const capped = Math.min(lines, 10);
      conn.send({ type:'attack', lines: capped });
    }
  }

  receiveAttack(lines){
    this.pendingGarbage.push({ lines: lines, hole: this.rng.nextInt(COLS) });
  }

  applyGarbage(){
    if(this.pendingGarbage.length === 0) return;
    let total = this.pendingGarbage.reduce((s,g)=>s+g.lines,0);
    for(let i=0;i<total && i<ROWS;i++) this.board.shift();
    for(const g of this.pendingGarbage){
      const hole = g.hole;
      for(let i=0;i<g.lines;i++){
        const row = Array(COLS).fill('G');
        row[hole] = 0;
        this.board.push(row);
      }
    }
    addChatMessage(`Received ${total} garbage lines!`, 'System');
    this.pendingGarbage = [];
  }

  updateStats(){
    const elapsed = Math.max(1, (nowMs() - this.gameStartTime)/1000);
    const pps = this.piecesPlaced / elapsed;
    const apm = (this.attacksSent / elapsed) * 60;
    const ppsEl = document.getElementById(`pps${this.playerId}`);
    const apmEl = document.getElementById(`apm${this.playerId}`);
    const b2bEl = document.getElementById(`b2b${this.playerId}`);
    const comboEl = document.getElementById(`combo${this.playerId}`);
    if(ppsEl) ppsEl.textContent = pps.toFixed(2);
    if(apmEl) apmEl.textContent = apm.toFixed(2);
    if(b2bEl) b2bEl.textContent = this.b2bCounter;
    if(comboEl) comboEl.textContent = Math.max(0, this.comboCounter);
  }

  getState(){
    return {
      board: deepClone(this.board),
      currentPiece: this.currentPiece,
      currentX: this.currentX,
      currentY: this.currentY,
      currentRotation: this.currentRotation,
      holdPiece: this.holdPiece,
      queue: [...this.queue],
      piecesPlaced: this.piecesPlaced,
      attacksSent: this.attacksSent,
      b2bCounter: this.b2bCounter,
      comboCounter: this.comboCounter
    };
  }

  setState(state){
    if(!state) return;
    this.board = state.board.map(r=>[...r]);
    this.currentPiece = state.currentPiece;
    this.currentX = state.currentX;
    this.currentY = state.currentY;
    this.currentRotation = state.currentRotation;
    this.holdPiece = state.holdPiece;
    this.queue = [...state.queue];
    this.piecesPlaced = state.piecesPlaced;
    this.attacksSent = state.attacksSent;
    this.b2bCounter = state.b2bCounter;
    this.comboCounter = state.comboCounter;
    this.updateStats();
  }

  tick(deltaMs){
    // spawn cooldown timer
    if(this.spawnCooldownTimer > 0){
      this.spawnCooldownTimer -= deltaMs;
      if(this.spawnCooldownTimer <= 0) this.processSpawnBuffer();
    }

    // gravity
    this.gravityTimer += deltaMs;
    if(this.gravityTimer >= this.gravityMs){
      this.gravityTimer = 0;
      if(!this.softDrop()){
        // touching ground
        this.isTouchingGround = true;
        this.lockDelayTimer += this.gravityMs;
        if(this.lockDelayTimer >= this.lockDelayMs || this.lockResetCount >= this.maxLockResets){
          const ok = this.lockPiece();
          if(!ok){
            // game over
            return false;
          }
        }
      } else {
        this.isTouchingGround = false;
        this.lockDelayTimer = 0;
      }
    }

    // DAS/ARR handling (called externally by input loop)
    return true;
  }

  draw(){
    // main canvas
    clearCanvas(this.ctx, this.canvas.width, this.canvas.height);
    // grid background
    this.ctx.fillStyle = '#0a0e27';
    this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height);
    // draw board cells
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const cell = this.board[r][c];
        if(cell){
          const color = (cell === 'G') ? '#666' : SHAPES[cell].color;
          drawBlock(this.ctx, c*BLOCK_SIZE, r*BLOCK_SIZE, color);
        }
      }
    }
    // ghost
    if(this.currentPiece){
      let gy = this.currentY;
      while(this.isValidPosition(this.currentX, gy+1, this.currentRotation)) gy++;
      this.drawPiece(this.ctx, this.currentPiece, this.currentX, gy, this.currentRotation, 0.25);
      this.drawPiece(this.ctx, this.currentPiece, this.currentX, this.currentY, this.currentRotation, 1.0);
    }
    // hold & queue
    this.drawHold();
    this.drawQueue();
  }

  drawPiece(ctx, pieceType, x, y, rotation, alpha=1){
    const shape = SHAPES[pieceType].shape[rotation];
    const color = SHAPES[pieceType].color;
    for(let r=0;r<shape.length;r++){
      for(let c=0;c<shape[r].length;c++){
        if(shape[r][c]){
          drawBlock(ctx, (x+c)*BLOCK_SIZE, (y+r)*BLOCK_SIZE, color, alpha);
        }
      }
    }
  }

  drawHold(){
    if(!this.holdCtx) return;
    clearCanvas(this.holdCtx, this.holdCanvas.width, this.holdCanvas.height);
    this.holdCtx.fillStyle = '#0a0e27';
    this.holdCtx.fillRect(0,0,this.holdCanvas.width,this.holdCanvas.height);
    if(this.holdPiece){
      const shape = SHAPES[this.holdPiece].shape[0];
      const color = SHAPES[this.holdPiece].color;
      const offsetX = (this.holdCanvas.width - shape[0].length*PREVIEW_BLOCK_SIZE)/2;
      const offsetY = (this.holdCanvas.height - shape.length*PREVIEW_BLOCK_SIZE)/2;
      for(let r=0;r<shape.length;r++){
        for(let c=0;c<shape[r].length;c++){
          if(shape[r][c]){
            this.holdCtx.fillStyle = color;
            this.holdCtx.fillRect(offsetX + c*PREVIEW_BLOCK_SIZE, offsetY + r*PREVIEW_BLOCK_SIZE, PREVIEW_BLOCK_SIZE-1, PREVIEW_BLOCK_SIZE-1);
          }
        }
      }
    }
  }

  drawQueue(){
    if(!this.queueCtx) return;
    clearCanvas(this.queueCtx, this.queueCanvas.width, this.queueCanvas.height);
    this.queueCtx.fillStyle = '#0a0e27';
    this.queueCtx.fillRect(0,0,this.queueCanvas.width,this.queueCanvas.height);
    for(let i=0;i<6;i++){
      const piece = this.queue[i];
      if(!piece) continue;
      const shape = SHAPES[piece].shape[0];
      const color = SHAPES[piece].color;
      const offsetX = (this.queueCanvas.width - shape[0].length*PREVIEW_BLOCK_SIZE)/2;
      const offsetY = i*80 + (80 - shape.length*PREVIEW_BLOCK_SIZE)/2;
      for(let r=0;r<shape.length;r++){
        for(let c=0;c<shape[r].length;c++){
          if(shape[r][c]){
            this.queueCtx.fillStyle = color;
            this.queueCtx.fillRect(offsetX + c*PREVIEW_BLOCK_SIZE, offsetY + r*PREVIEW_BLOCK_SIZE, PREVIEW_BLOCK_SIZE-1, PREVIEW_BLOCK_SIZE-1);
          }
        }
      }
    }
  }
}

/* -------------------------
   Global game instances & loop
   ------------------------- */
let gameState1 = null, gameState2 = null;
let gameRunning = false;
let lastFrameTime = nowMs();
let lastStateSend = nowMs();

/* -------------------------
   UI elements & key bindings
   (keep same IDs as original HTML)
   ------------------------- */
const keyBindings = {
  left: document.getElementById('keyLeft')?.value || 'ArrowLeft',
  right: document.getElementById('keyRight')?.value || 'ArrowRight',
  softDrop: document.getElementById('keySoftDrop')?.value || 'ArrowDown',
  hardDrop: document.getElementById('keyHardDrop')?.value || ' ',
  rotateCW: document.getElementById('keyRotateCW')?.value || 'ArrowUp',
  rotateCCW: document.getElementById('keyRotateCCW')?.value || 'z',
  rotate180: document.getElementById('keyRotate180')?.value || 'x',
  hold: document.getElementById('keyHold')?.value || 'c'
};

// allow changing key bindings (existing UI behavior)
['left','right','softDrop','hardDrop','rotateCW','rotateCCW','rotate180','hold'].forEach(action=>{
  const el = document.getElementById('key' + action.charAt(0).toUpperCase() + action.slice(1));
  if(!el) return;
  el.addEventListener('click', ()=>{
    el.value = 'Press a key...';
    const listener = (e)=>{
      e.preventDefault();
      keyBindings[action] = e.key;
      el.value = e.key;
      document.removeEventListener('keydown', listener);
    };
    document.addEventListener('keydown', listener);
  });
});

/* -------------------------
   Chat helpers
   ------------------------- */
function addChatMessage(message, sender='System'){
  const chatMessages = document.getElementById('chatMessages');
  if(!chatMessages) return;
  const div = document.createElement('div');
  div.className = 'chat-message';
  div.textContent = `${sender}: ${message}`;
  chatMessages.appendChild(div);
  chatMessages.scrollTop = chatMessages.scrollHeight;
}
document.getElementById('sendChatBtn')?.addEventListener('click', ()=>{
  const input = document.getElementById('chatInput');
  if(!input) return;
  const msg = input.value.trim();
  if(msg && conn && conn.open){
    conn.send({ type:'chat', message: msg });
    addChatMessage(msg, 'You');
    input.value = '';
  }
});
document.getElementById('chatInput')?.addEventListener('keypress', (e)=>{
  if(e.key === 'Enter') document.getElementById('sendChatBtn')?.click();
});

/* -------------------------
   Compact PeerJS connection
   ------------------------- */
let peer = null, conn = null, myPeerId = null, isHost = false, gameSeed = null;

function makePeer(){
  if(peer) return;
  peer = new Peer({ config: { iceServers: [{ urls:'stun:stun.l.google.com:19302' }] } });
  peer.on('open', id=>{
    myPeerId = id;
    const disp = document.getElementById('peerIdDisplay');
    if(disp) disp.textContent = id;
    document.getElementById('myPeerId')?.classList.remove('hidden');
    addChatMessage(`Your Peer ID: ${id}`);
  });
  peer.on('connection', c=>{
    conn = c;
    wireConnection();
    isHost = true;
    gameSeed = Math.floor(Math.random()*1e9);
    addChatMessage(`Generated game seed: ${gameSeed}`, 'System');
    setTimeout(()=>{
      if(conn && conn.open) conn.send({ type:'start', seed: gameSeed });
      startGame();
    }, 600);
  });
  peer.on('error', err=>{
    addChatMessage(`Peer error: ${err && err.type ? err.type : err}`, 'System');
  });
}

function wireConnection(){
  if(!conn) return;
  conn.on('data', data=>{
    if(!data || !data.type) return;
    switch(data.type){
      case 'chat': addChatMessage(data.message, 'Opponent'); break;
      case 'attack': if(gameState1) gameState1.receiveAttack(data.lines); break;
      case 'start':
        if(data.seed){ gameSeed = data.seed; addChatMessage(`Received seed: ${gameSeed}`, 'System'); }
        startGame();
        break;
      case 'gameState':
        if(gameState2) gameState2.setState(data.state);
        break;
      case 'restart':
        if(data.seed) gameSeed = data.seed;
        restartGame();
        break;
      case 'gameOver':
        gameRunning = false;
        addChatMessage('Opponent lost! You win!', 'System');
        document.getElementById('gameStatus').textContent = 'You Win!';
        break;
    }
  });
  conn.on('close', ()=>{
    addChatMessage('Opponent disconnected', 'System');
    document.getElementById('gameStatus').textContent = 'Opponent disconnected';
    gameRunning = false;
  });
  conn.on('error', err=>{
    addChatMessage(`Connection error: ${err}`, 'System');
  });
}

function createGame(){
  makePeer();
  document.getElementById('createGameBtn').disabled = true;
  document.getElementById('gameStatus').textContent = 'Waiting for opponent to join...';
}

function joinGame(){
  const opponentId = document.getElementById('opponentPeerId')?.value.trim();
  if(!opponentId){ addChatMessage('Please enter an opponent Peer ID', 'System'); return; }
  makePeer();
  const tryConnect = ()=>{
    if(!myPeerId) return setTimeout(tryConnect, 200);
    conn = peer.connect(opponentId);
    conn.on('open', ()=>{
      wireConnection();
      addChatMessage('Connected to opponent!', 'System');
      document.getElementById('gameStatus').textContent = 'Connected! Waiting for host to start...';
      document.getElementById('joinGameBtn').disabled = true;
    });
    conn.on('error', err=> addChatMessage(`Failed to connect: ${err}`, 'System'));
  };
  tryConnect();
}

document.getElementById('createGameBtn')?.addEventListener('click', createGame);
document.getElementById('joinGameBtn')?.addEventListener('click', joinGame);
document.getElementById('restartBtn')?.addEventListener('click', ()=>{
  gameSeed = Math.floor(Math.random()*1e9);
  addChatMessage(`New game seed: ${gameSeed}`, 'System');
  if(conn && conn.open) conn.send({ type:'restart', seed: gameSeed });
  restartGame();
});

/* -------------------------
   Start / Restart logic
   ------------------------- */
function restartGame(){
  gameRunning = false;
  setTimeout(()=>{ startGame(); addChatMessage('Game restarted!', 'System'); }, 400);
}

function startGame(){
  gameRunning = true;
  document.getElementById('gameArea')?.classList.remove('hidden');
  document.getElementById('restartBtn')?.classList.remove('hidden');
  document.getElementById('gameStatus').textContent = 'Game in progress!';
  if(!gameSeed){ gameSeed = Math.floor(Math.random()*1e9); addChatMessage(`Generated game seed: ${gameSeed}`, 'System'); }
  gameState1 = new GameState('gameCanvas1','holdCanvas1','queueCanvas1',1, gameSeed);
  gameState2 = new GameState('gameCanvas2','holdCanvas2','queueCanvas2',2, gameSeed);
  const startTime = nowMs();
  gameState1.gameStartTime = startTime;
  gameState2.gameStartTime = startTime;
  gameState1.spawnPiece();
  gameState2.spawnPiece();
  lastFrameTime = nowMs();
  lastStateSend = nowMs();
  requestAnimationFrame(loop);
  addChatMessage('Game started! Good luck!', 'System');
}

/* -------------------------
   Main loop
   ------------------------- */
function loop(){
  if(!gameRunning) return;
  const t = nowMs();
  const delta = t - lastFrameTime;
  lastFrameTime = t;

  if(gameState1){
    // tick game state (gravity, spawn cooldown)
    const alive = gameState1.tick(delta);
    if(alive === false){
      addChatMessage('You lost! Click Restart to play again.', 'System');
      document.getElementById('gameStatus').textContent = 'Game Over! You lost.';
      gameRunning = false;
      if(conn && conn.open) conn.send({ type:'gameOver' });
      return;
    }

    // DAS/ARR timers handled by input loop; here we just draw and send state
    gameState1.draw();
    if(gameState2) gameState2.draw();

    // send state periodically
    if(conn && conn.open && (t - lastStateSend) >= STATE_SEND_INTERVAL){
      conn.send({ type:'gameState', state: gameState1.getState() });
      lastStateSend = t;
    }
  }

  requestAnimationFrame(loop);
}

/* -------------------------
   Input handling (DAS/ARR + buffering)
   - Uses keydown/keyup and per-key timers
   ------------------------- */
const keysHeld = {};
const dasState = {}; // key -> { dasTimer, arrTimer, direction }

function getDasMs(){ return parseInt(document.getElementById('das')?.value || '167', 10); }
function getArrMs(){ return parseInt(document.getElementById('arr')?.value || '0', 10); }
function getDcdMs(){ return parseInt(document.getElementById('dcd')?.value || '0', 10); }

document.addEventListener('keydown', (e)=>{
  if(!gameRunning || !gameState1) return;
  if(keysHeld[e.key]) return; // ignore repeats
  keysHeld[e.key] = true;

  // left/right start immediate move and start DAS
  if(e.key === keyBindings.left){
    e.preventDefault();
    gameState1.move(-1);
    dasState[e.key] = { dasTimer:0, arrTimer:0, direction:-1 };
  } else if(e.key === keyBindings.right){
    e.preventDefault();
    gameState1.move(1);
    dasState[e.key] = { dasTimer:0, arrTimer:0, direction:1 };
  } else if(e.key === keyBindings.softDrop){
    e.preventDefault();
    gameState1.softDrop();
  } else if(e.key === keyBindings.hardDrop){
    e.preventDefault();
    const success = gameState1.hardDrop();
    if(!success){
      addChatMessage('You lost! Click Restart to play again.', 'System');
      document.getElementById('gameStatus').textContent = 'Game Over! You lost.';
      gameRunning = false;
      if(conn && conn.open) conn.send({ type:'gameOver' });
    }
    // spawn handled by lockPiece -> spawnPiece
  } else if(e.key === keyBindings.rotateCW){
    e.preventDefault();
    gameState1.rotate('cw');
  } else if(e.key === keyBindings.rotateCCW){
    e.preventDefault();
    gameState1.rotate('ccw');
  } else if(e.key === keyBindings.rotate180){
    e.preventDefault();
    gameState1.rotate('180');
  } else if(e.key === keyBindings.hold){
    e.preventDefault();
    gameState1.holdCurrentPiece();
  }
});

// keyup: stop DAS
document.addEventListener('keyup', (e)=>{
  delete keysHeld[e.key];
  delete dasState[e.key];
});

// DAS/ARR processing loop (runs independently at ~60Hz)
setInterval(()=>{
  if(!gameRunning || !gameState1) return;
  const dasMs = getDasMs();
  const arrMs = getArrMs();
  const tick = 16; // ms per tick
  for(const k in dasState){
    const s = dasState[k];
    s.dasTimer += tick;
    if(s.dasTimer >= dasMs){
      s.arrTimer += tick;
      if(arrMs === 0 || s.arrTimer >= arrMs){
        // perform repeated move
        gameState1.move(s.direction);
        s.arrTimer = 0;
      }
    }
  }
}, 16);

/* -------------------------
   Periodic spawn-cooldown processing
   (ensures buffered inputs are applied promptly)
   ------------------------- */
setInterval(()=>{
  if(gameState1 && gameState1.spawnCooldownTimer > 0){
    // spawnCooldownTimer is decremented in tick; nothing to do here
  }
}, 50);

/* -------------------------
   Peer ID copy helper
   ------------------------- */
function copyPeerId(){
  const peerId = document.getElementById('peerIdDisplay')?.textContent || '';
  if(peerId) navigator.clipboard.writeText(peerId).then(()=> addChatMessage('Peer ID copied to clipboard!', 'System'));
}

/* -------------------------
   Connect UI wiring (copy existing HTML behavior)
   ------------------------- */
window.copyPeerId = copyPeerId;

/* -------------------------
   Initialize small welcome messages
   ------------------------- */
addChatMessage('Welcome to Tetris Online Battle!');
addChatMessage('Click "Create Game" to host or enter a Peer ID to join.');

/* -------------------------
   Expose some internals for debugging (optional)
   ------------------------- */
window.__gameState1 = () => gameState1;
window.__gameState2 = () => gameState2;
window.__makePeer = makePeer;

</script>

</body>
</html>
