<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris Multiplayer - Refined</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        :root {
            --bg-dark: #0a0e27;
            --bg-grid: #151b3d;
            --accent-cyan: #00ffff;
            --accent-pink: #ff00ff;
            --text-primary: #ffffff;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: 'Orbitron', sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }

        #ui-layer { margin: 15px; text-align: center; z-index: 10; }
        .game-container { display: flex; gap: 30px; align-items: flex-start; }
        
        .player-section { 
            display: flex; gap: 10px; padding: 15px; 
            background: rgba(255, 255, 255, 0.05); border: 2px solid var(--bg-grid);
        }

        canvas { background: #000; display: block; border: 1px solid #333; }
        .side-panels { display: flex; flex-direction: column; gap: 10px; }
        
        .controls { margin: 10px 0; display: flex; gap: 5px; justify-content: center; }
        input, button { 
            padding: 8px 12px; font-family: 'Orbitron'; background: #1a1a2e; 
            color: white; border: 1px solid var(--accent-cyan); outline: none;
        }
        button:hover { background: var(--accent-cyan); color: black; cursor: pointer; }

        #chat-container {
            position: fixed; bottom: 10px; right: 10px; width: 280px;
            display: flex; flex-direction: column;
            background: rgba(10, 14, 39, 0.95); border: 1px solid var(--accent-cyan);
            max-height: 300px;
        }
        #chat-messages { height: 200px; overflow-y: auto; padding: 8px; font-size: 12px; }
        .chat-input-area { display: flex; border-top: 1px solid var(--accent-cyan); }
        #chat-input { flex-grow: 1; border: none; padding: 8px; background: transparent; color: white; }

        .score-board { font-size: 24px; color: var(--accent-cyan); margin: 5px 0; }
    </style>
</head>
<body>

<div id="ui-layer">
    <h1 style="text-shadow: 0 0 10px var(--accent-cyan);">TETR.IO CLONE</h1>
    <div class="score-board"><span id="p1-wins">0</span> - <span id="p2-wins">0</span></div>
    <div class="controls">
        <button id="create-btn">Host Match</button>
        <input type="text" id="join-id" placeholder="Paste ID here">
        <button id="join-btn">Join</button>
        <button id="restart-btn" style="display:none; border-color: var(--accent-pink);">Restart</button>
    </div>
    <div id="my-id-label">Your ID: <span id="my-id" style="color:var(--accent-pink)">...</span></div>
</div>

<div class="game-container">
    <div class="player-section">
        <div class="side-panels">
            <p>HOLD</p>
            <canvas id="hold1" width="80" height="80"></canvas>
            <div id="stats1" style="font-size: 10px; margin-top: 20px;">LINES: 0<br>ATTACK: 0</div>
        </div>
        <div>
            <p>YOU</p>
            <canvas id="board1" width="300" height="600"></canvas>
        </div>
        <div class="side-panels">
            <p>NEXT</p>
            <canvas id="queue1" width="80" height="400"></canvas>
        </div>
    </div>

    <div class="player-section">
        <div class="side-panels">
            <p>HOLD</p>
            <canvas id="hold2" width="80" height="80"></canvas>
            <div id="stats2" style="font-size: 10px; margin-top: 20px;">LINES: 0<br>ATTACK: 0</div>
        </div>
        <div>
            <p>ENEMY</p>
            <canvas id="board2" width="300" height="600"></canvas>
        </div>
        <div class="side-panels">
            <p>NEXT</p>
            <canvas id="queue2" width="80" height="400"></canvas>
        </div>
    </div>
</div>

<div id="chat-container">
    <div id="chat-messages"></div>
    <div class="chat-input-area">
        <input type="text" id="chat-input" placeholder="Type message...">
    </div>
</div>

<script>
/** SEEDED RNG **/
class SeededRandom {
    constructor(seed) { this.state = seed || Math.floor(Math.random() * 1000000); }
    next() {
        this.state = (this.state * 1664525 + 1013904223) % 4294967296;
        return this.state / 4294967296;
    }
}

const COLS = 10, ROWS = 20, BLOCK = 30;
const COLORS = { I:'#00f0f0', O:'#f0f000', T:'#a000f0', S:'#00f000', Z:'#f00000', J:'#0000f0', L:'#f0a000', grey:'#555' };
const SHAPES = {
    I:[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]], O:[[1,1],[1,1]], T:[[0,1,0],[1,1,1],[0,0,0]],
    S:[[0,1,1],[1,1,0],[0,0,0]], Z:[[1,1,0],[0,1,1],[0,0,0]], J:[[1,0,0],[1,1,1],[0,0,0]], L:[[0,0,1],[1,1,1],[0,0,0]]
};

const KICKS = {
    "0-1":[[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]], "1-0":[[0,0],[1,0],[1,-1],[0,2],[1,2]],
    "1-2":[[0,0],[1,0],[1,-1],[0,2],[1,2]], "2-1":[[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],
    "2-3":[[0,0],[1,0],[1,1],[0,-2],[1,-2]], "3-2":[[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],
    "3-0":[[0,0],[-1,0],[-1,-1],[0,2],[-1,2]], "0-3":[[0,0],[1,0],[1,1],[0,-2],[1,-2]]
};

class GameState {
    constructor(bId, hId, qId, pNum, seed) {
        this.canvas = document.getElementById(bId); this.ctx = this.canvas.getContext('2d');
        this.holdCanvas = document.getElementById(hId); this.queueCanvas = document.getElementById(qId);
        this.pNum = pNum; this.rng = new SeededRandom(seed);
        this.board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
        this.queue = []; this.holdPiece = null; this.canHold = true;
        this.lines = 0; this.attack = 0; this.isGameOver = false;
        
        this.curr = null; this.type = ''; this.x = 0; this.y = 0; this.rot = 0;
        this.dropTimer = 0; this.lockTimer = 0; this.lastMoveRot = false; this.lastKick = 0;

        this.fillQueue(); this.spawn();
    }

    fillQueue() {
        while(this.queue.length < 14) {
            let bag = Object.keys(SHAPES);
            for (let i = bag.length - 1; i > 0; i--) {
                const j = Math.floor(this.rng.next() * (i + 1));
                [bag[i], bag[j]] = [bag[j], bag[i]];
            }
            this.queue.push(...bag);
        }
    }

    spawn(type = null) {
        this.type = type || this.queue.shift(); this.fillQueue();
        this.curr = SHAPES[this.type]; this.rot = 0;
        this.x = Math.floor(COLS/2) - Math.floor(this.curr[0].length/2); this.y = 0;
        this.canHold = true; this.lastMoveRot = false;
        if (!this.isValid(this.x, this.y, this.curr)) {
            this.isGameOver = true;
            if (this.pNum === 1 && conn) conn.send({type: 'gameover'});
            return false;
        }
        return true;
    }

    isValid(nx, ny, p) {
        return p.every((row, dy) => row.every((v, dx) => {
            let x = nx + dx, y = ny + dy;
            return !v || (x >= 0 && x < COLS && y < ROWS && (y < 0 || !this.board[y][x]));
        }));
    }

    rotate(dir) {
        const nextRot = (this.rot + (dir === 'cw' ? 1 : 3)) % 4;
        const nextP = this.rotateMat(this.curr, dir);
        const kicks = KICKS[`${this.rot}-${nextRot}`] || [[0,0]];
        for (let i=0; i<kicks.length; i++) {
            const [kx, ky] = kicks[i];
            if (this.isValid(this.x + kx, this.y - ky, nextP)) {
                this.x += kx; this.y -= ky; this.curr = nextP; this.rot = nextRot;
                this.lastMoveRot = true; this.lastKick = i; this.lockTimer = 0;
                return;
            }
        }
    }

    rotateMat(m, dir) {
        let n = m.length, res = Array.from({length:n},()=>Array(n).fill(0));
        for(let y=0; y<n; y++) for(let x=0; x<n; x++)
            if(dir==='cw') res[x][n-1-y] = m[y][x]; else res[n-1-x][y] = m[y][x];
        return res;
    }

    move(dx) {
        if (this.isValid(this.x + dx, this.y, this.curr)) {
            this.x += dx; this.lastMoveRot = false; this.lockTimer = 0;
            return true;
        }
        return false;
    }

    drop() {
        if (this.isValid(this.x, this.y + 1, this.curr)) {
            this.y++; this.lastMoveRot = false; return true;
        }
        return false;
    }

    hardDrop() {
        while(this.drop()){}
        this.lock();
    }

    hold() {
        if (!this.canHold) return;
        const t = this.holdPiece; this.holdPiece = this.type;
        this.spawn(t); this.canHold = false;
    }

    lock() {
        this.curr.forEach((row, dy) => row.forEach((v, dx) => {
            if (v && this.y + dy >= 0) this.board[this.y+dy][this.x+dx] = this.type;
        }));
        const spin = this.checkSpin();
        this.clearLines(spin);
        if (!this.spawn()) this.isGameOver = true;
        if (this.pNum === 1 && conn) sendState();
    }

    checkSpin() {
        if (this.type !== 'T' || !this.lastMoveRot) return {isSpin:false};
        const corners = [[this.x,this.y],[this.x+2,this.y],[this.x,this.y+2],[this.x+2,this.y+2]];
        let f = 0;
        corners.forEach(([cx,cy]) => { if(cx<0||cx>=COLS||cy>=ROWS||(cy>=0&&this.board[cy][cx])) f++; });
        return { isSpin: f >= 3, isMini: f >= 3 && this.lastKick < 4 };
    }

    clearLines(spin) {
        let c = 0;
        for (let y = ROWS-1; y>=0; y--) {
            if (this.board[y].every(cell => cell !== 0)) {
                this.board.splice(y, 1); this.board.unshift(Array(COLS).fill(0));
                c++; y++;
            }
        }
        if (c > 0 || spin.isSpin) {
            let dmg = spin.isSpin ? (spin.isMini ? c+1 : c*2) : (c === 4 ? 4 : Math.max(0, c-1));
            this.attack += dmg; this.lines += c;
            if (dmg > 0 && conn && this.pNum === 1) conn.send({type:'attack', amt:dmg});
        }
    }

    update(dt) {
        if (this.isGameOver) return;
        this.dropTimer += dt;
        if (this.dropTimer > 800) {
            if (!this.drop()) {
                this.lockTimer += dt;
                if (this.lockTimer >= 500) { this.lock(); this.lockTimer = 0; }
            } else { this.lockTimer = 0; }
            this.dropTimer = 0;
        } else if (!this.isValid(this.x, this.y + 1, this.curr)) {
            this.lockTimer += dt;
            if (this.lockTimer >= 500) this.lock();
        }
    }

    draw() {
        this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
        this.board.forEach((r,y) => r.forEach((v,x) => { if(v) this.drawBlk(this.ctx,x,y,COLORS[v]); }));
        
        // Ghost
        let gy = this.y; while(this.isValid(this.x, gy+1, this.curr)) gy++;
        this.ctx.globalAlpha = 0.2;
        this.curr.forEach((r,dy) => r.forEach((v,dx) => { if(v) this.drawBlk(this.ctx,this.x+dx,gy+dy,COLORS[this.type]); }));
        this.ctx.globalAlpha = 1.0;

        // Piece
        this.curr.forEach((r,dy) => r.forEach((v,dx) => { if(v) this.drawBlk(this.ctx,this.x+dx,this.y+dy,COLORS[this.type]); }));
        this.drawUI();
    }

    drawBlk(ctx, x, y, col, sz = BLOCK) {
        ctx.fillStyle = col; ctx.fillRect(x*sz, y*sz, sz, sz);
        ctx.strokeStyle = 'rgba(0,0,0,0.4)'; ctx.strokeRect(x*sz, y*sz, sz, sz);
    }

    drawUI() {
        document.getElementById(`stats${this.pNum}`).innerHTML = `LINES: ${this.lines}<br>ATTACK: ${this.attack}`;
        
        // Hold
        const hCtx = this.holdCanvas.getContext('2d'); hCtx.clearRect(0,0,80,80);
        if (this.holdPiece) this.drawPreview(hCtx, this.holdPiece);

        // Queue
        const qCtx = this.queueCanvas.getContext('2d'); qCtx.clearRect(0,0,80,400);
        this.queue.slice(0, 5).forEach((type, i) => this.drawPreview(qCtx, type, i * 70 + 10));
    }

    drawPreview(ctx, type, yOffset = 10) {
        const p = SHAPES[type], sz = 15;
        p.forEach((r, y) => r.forEach((v, x) => {
            if (v) {
                ctx.fillStyle = COLORS[type];
                ctx.fillRect(x*sz + 10, y*sz + yOffset, sz, sz);
            }
        }));
    }
}

/** NETWORK & INPUTS **/
let peer = new Peer(), conn, gameState1, gameState2, isHost = false;
let wins = [0, 0];
const keys = {};
let dasTimer = 0, arrTimer = 0, DAS = 170, ARR = 30;

window.addEventListener('keydown', e => {
    let k = e.key.toLowerCase();
    if (!keys[k]) {
        if (k === 'w' || e.key === 'ArrowUp') gameState1.rotate('cw');
        if (k === 'q') gameState1.rotate('ccw');
        if (k === ' ') { e.preventDefault(); gameState1.hardDrop(); }
        if (k === 'c' || e.key === 'Shift') gameState1.hold();
        if (k === 't') { e.preventDefault(); document.getElementById('chat-input').focus(); }
    }
    keys[k] = true;
});
window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; dasTimer = 0; });

function handleInput(dt) {
    if (!gameState1 || gameState1.isGameOver) return;
    if (keys['s'] || keys['arrowdown']) gameState1.drop();
    if (keys['a'] || keys['arrowleft']) {
        if (dasTimer === 0) gameState1.move(-1);
        dasTimer += dt;
        if (dasTimer >= DAS) {
            arrTimer += dt;
            if (arrTimer >= ARR) { gameState1.move(-1); arrTimer = 0; }
        }
    } else if (keys['d'] || keys['arrowright']) {
        if (dasTimer === 0) gameState1.move(1);
        dasTimer += dt;
        if (dasTimer >= DAS) {
            arrTimer += dt;
            if (arrTimer >= ARR) { gameState1.move(1); arrTimer = 0; }
        }
    } else { dasTimer = 0; }
}

peer.on('open', id => document.getElementById('my-id').innerText = id);

document.getElementById('create-btn').onclick = () => {
    isHost = true; document.getElementById('restart-btn').style.display = 'inline-block';
    addChat("System", "Waiting for someone to join...");
};

document.getElementById('join-btn').onclick = () => {
    conn = peer.connect(document.getElementById('join-id').value);
    setupConn();
};

peer.on('connection', c => { conn = c; isHost = true; setupConn(); let s = Date.now(); conn.send({type:'init', seed:s}); start(s); });

function setupConn() {
    conn.on('data', data => {
        if (data.type === 'init') start(data.seed);
        if (data.type === 'update') {
            gameState2.board = data.board; gameState2.holdPiece = data.holdPiece;
            gameState2.queue = data.queue; gameState2.lines = data.lines; gameState2.attack = data.attack;
        }
        if (data.type === 'attack') receiveGarb(data.amt);
        if (data.type === 'chat') addChat("Opponent", data.msg);
        if (data.type === 'gameover') {
            wins[0]++; updateWins();
            addChat("System", "Opponent topped out! You win.");
        }
        if (data.type === 'restart') start(data.seed);
    });
}

function start(seed) {
    gameState1 = new GameState('board1', 'hold1', 'queue1', 1, seed);
    gameState2 = new GameState('board2', 'hold2', 'queue2', 2, seed);
    requestAnimationFrame(loop);
}

function updateWins() {
    document.getElementById('p1-wins').innerText = wins[0];
    document.getElementById('p2-wins').innerText = wins[1];
}

function sendState() {
    conn.send({ type:'update', board:gameState1.board, holdPiece:gameState1.holdPiece, queue:gameState1.queue, lines:gameState1.lines, attack:gameState1.attack });
}

function receiveGarb(amt) {
    let hole = Math.floor(Math.random()*COLS);
    for(let i=0; i<amt; i++) {
        gameState1.board.shift();
        let r = Array(COLS).fill('grey'); r[hole] = 0;
        gameState1.board.push(r);
    }
}

document.getElementById('restart-btn').onclick = () => {
    let s = Date.now(); conn.send({type:'restart', seed:s}); start(s);
};

let last = 0;
function loop(t) {
    const dt = t - last; last = t;
    handleInput(dt); gameState1.update(dt);
    gameState1.draw(); gameState2.draw();
    if (!gameState1.isGameOver) requestAnimationFrame(loop);
    else { wins[1]++; updateWins(); addChat("System", "You topped out."); }
}

const chatIn = document.getElementById('chat-input');
chatIn.onkeydown = e => {
    if (e.key === 'Enter' && chatIn.value.trim()) {
        addChat("You", chatIn.value);
        if(conn) conn.send({type:'chat', msg:chatIn.value});
        chatIn.value = ""; chatIn.blur();
    }
};

function addChat(who, msg) {
    const d = document.createElement('div');
    d.innerHTML = `<b style="color:var(--accent-cyan)">${who}:</b> ${msg}`;
    const c = document.getElementById('chat-messages');
    c.appendChild(d); c.scrollTop = c.scrollHeight;
}
</script>
</body>
</html>
